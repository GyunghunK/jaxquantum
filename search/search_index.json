{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to jaxquantum","text":"<p>S. R. Jha, S. Chowdhury, M. Hays, J. A. Grover, W. D. Oliver</p> <p>Docs: equs.github.io/jaxquantum</p> <p>Community Discord: discord.gg/frWqbjvZ4s</p> <p><code>jaxquantum</code> leverages JAX to enable the auto differentiable and (CPU, GPU, TPU) accelerated simulation of quantum dynamical systems, including tooling such as operator construction, unitary evolution and master equation solving. As such, <code>jaxquantum</code> serves as a QuTiP drop-in replacement written entirely in JAX.</p> <p>This package also serves as an essential dependency for <code>bosonic</code> and <code>qcsys</code>. Together, these packages form an end-to-end toolkit for quantum circuit design, simulation and control. </p>"},{"location":"index.html#installation","title":"Installation","text":""},{"location":"index.html#installing-from-source-recommended","title":"Installing from source (recommended)","text":"<p>Recommended: As this is a rapidly evolving project, we recommend installing the latest version of <code>jaxquantum</code> from source as follows:</p> <pre><code>pip install git+https://github.com/EQuS/jaxquantum.git\n</code></pre>"},{"location":"index.html#installing-from-source-in-editable-mode-recommended-for-developers","title":"Installing from source in editable mode (recommended for developers)","text":"<p>If you are interested in contributing to the package, please clone this repository and install this package in editable mode after changing into the root directory of this repository:</p> <pre><code>pip install -e \".[dev,docs]\"\n</code></pre> <p>This will also install extras from the <code>dev</code> and <code>docs</code> flags, which can be useful when developing the package. Since this is installed in editable mode, the package will automatically be updated after pulling new changes in the repository. </p>"},{"location":"index.html#installing-from-pypi-not-recommended","title":"Installing from PyPI (not recommended)","text":"<p><code>jaxquantum</code> is also published on PyPI. Simply run the following code to install the package:</p> <pre><code>pip install jaxquantum\n</code></pre> <p>For more details, please visit the getting started &gt; installation section of our docs.</p>"},{"location":"index.html#an-example","title":"An Example","text":"<p>Here's an example of how to set up a simulation in jaxquantum.</p> <pre><code>from jax import jit\nimport jaxquantum as jqt\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\nomega_q = 5.0 #GHz\nOmega = .1\ng_state = jqt.basis(2,0) ^ jqt.basis(2,0)\ng_state_dm = g_state.to_dm()\n\nts = jnp.linspace(0,5*jnp.pi/Omega,101)\nc_ops = [0.1*jqt.sigmam()^jqt.identity(N=2)]\n\nsz0 = jqt.sigmaz() ^ jqt.identity(N=2)\n\n@jit\ndef Ht(t):\n    H0 = omega_q/2.0*((jqt.sigmaz()^jqt.identity(N=2)) + (jqt.identity(N=2)^jqt.sigmaz()))\n    H1 = Omega*jnp.cos((omega_q)*t)*((jqt.sigmax()^jqt.identity(N=2)) + (jqt.identity(N=2)^jqt.sigmax()))\n    return H0 + H1\n\n\nstates = jqt.mesolve(g_state_dm, ts, c_ops=c_ops, Ht=Ht) \nszt = jnp.real(jqt.calc_expect(sz0, states))\n\n\nfig, ax = plt.subplots(1, dpi=200, figsize=(4,3))\nax.plot(ts, szt)\nax.set_xlabel(\"Time (ns)\")\nax.set_ylabel(\"&lt;\u03c3z(t)&gt;\")\nfig.tight_layout()\n</code></pre>"},{"location":"index.html#acknowledgements-history","title":"Acknowledgements &amp; History","text":"<p>Core Devs: Shantanu A. Jha, Shoumik Chowdhury</p> <p>This package was initially a small part of <code>bosonic</code>. In early 2022, <code>jaxquantum</code> was extracted and made into its own package. This package was briefly announced to the world at APS March Meeting 2023 and released to a select few academic groups shortly after. Since then, this package has been open sourced and developed while conducting research in the Engineering Quantum Systems Group at MIT with invaluable advice from Prof. William D. Oliver. </p>"},{"location":"index.html#citation","title":"Citation","text":"<p>Thank you for taking the time to try our package out. If you found it useful in your research, please cite us as follows:</p> <pre><code>@software{jha2024jaxquantum,\n  author = {Shantanu R. Jha and Shoumik Chowdhury and Max Hays and Jeff A. Grover and William D. Oliver},\n  title  = {An auto differentiable and hardware accelerated software toolkit for quantum circuit design, simulation and control},\n  url    = {https://github.com/EQuS/jaxquantum, https://github.com/EQuS/bosonic, https://github.com/EQuS/qcsys},\n  version = {0.1.0},\n  year   = {2024},\n}\n</code></pre> <p>S. R. Jha, S. Chowdhury, M. Hays, J. A. Grover, W. D. Oliver. An auto differentiable and hardware accelerated software toolkit for quantum circuit design, simulation and control (2024), in preparation.</p>"},{"location":"index.html#contributions-contact","title":"Contributions &amp; Contact","text":"<p>This package is open source and, as such, very open to contributions. Please don't hesitate to open an issue, report a bug, request a feature, or create a pull request. We are also open to deeper collaborations to create a tool that is more useful for everyone. If a discussion would be helpful, please email shanjha@mit.edu to set up a meeting. </p>"},{"location":"getting_started/examples.html","title":"Examples","text":"<p>Here are some examples to help you get started with <code>jaxquantum</code>. </p>"},{"location":"getting_started/examples.html#lossy-harmonic-oscillator","title":"Lossy Harmonic Oscillator","text":"<p>Let's simulate the time dynamics of a quantum harmonic oscillator with single photon loss. </p> <pre><code>from jax import jit\nimport jaxquantum as jqt \nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\nN = 100\n\nomega_a = 2.0*jnp.pi*5.0\nkappa = 2*jnp.pi*1\ninitial_state = jqt.displace(N, 0.1) @ jqt.basis(N,0)\ninitial_state_dm = initial_state.to_dm()\nts = jnp.linspace(0, 4*2*jnp.pi/omega_a, 101)\n\na = jqt.destroy(N)\nn = a.dag() @ a\n\nc_ops = [a*jnp.sqrt(kappa)]\n\n@jit\ndef Ht(t):\n    H0 = omega_a*n\n    return H0\n\nsolver_options = jqt.SolverOptions.create(progress_meter=True)\nstates = jqt.mesolve(initial_state_dm, ts, c_ops=c_ops, Ht=Ht, solver_options=solver_options) \nnt = jnp.real(jqt.calc_expect(n, states))\na_real = jnp.real(jqt.calc_expect(a, states))\na_imag = jnp.imag(jqt.calc_expect(a, states))\n\nfig, axs = plt.subplots(2,1, dpi=200, figsize=(6,5))\nax = axs[0]\nax.plot(ts, a_real, label=r\"$Re[\\langle a(t)\\rangle]$\")\nax.plot(ts, a_imag, label=r\"$Re[\\langle a(t)\\rangle]$\")\nax.set_xlabel(\"Time (ns)\")\nax.set_ylabel(\"Expectations\")\nax.legend()\n\nax = axs[1]\nax.plot(ts, nt, label=r\"$Re[\\langle n(t)\\rangle]$\")\nax.set_xlabel(\"Time (ns)\")\nax.set_ylabel(\"Expectations\")\nax.legend()\nfig.tight_layout()\n</code></pre> <p><code>text title=\"Output\" 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| [00:01&lt;00:00, 93.89%/s]</code> </p>"},{"location":"getting_started/installation.html","title":"Installation","text":""},{"location":"getting_started/installation.html#installation","title":"Installation","text":""},{"location":"getting_started/installation.html#installing-from-source-recommended","title":"Installing from source (recommended)","text":"<p>Recommended: As this is a rapidly evolving project, we recommend installing the latest version of <code>jaxquantum</code> from source as follows:</p> <pre><code>pip install git+https://github.com/EQuS/jaxquantum.git\n</code></pre>"},{"location":"getting_started/installation.html#installing-from-source-in-editable-mode-recommended-for-developers","title":"Installing from source in editable mode (recommended for developers)","text":"<p>If you are interested in contributing to the package, please clone this repository and install this package in editable mode after changing into the root directory of this repository:</p> <pre><code>pip install -e \".[dev,docs]\"\n</code></pre> <p>This will also install extras from the <code>dev</code> and <code>docs</code> flags, which can be useful when developing the package. Since this is installed in editable mode, the package will automatically be updated after pulling new changes in the repository. </p>"},{"location":"getting_started/installation.html#installing-from-pypi-not-recommended","title":"Installing from PyPI (not recommended)","text":"<p><code>jaxquantum</code> is also published on PyPI. Simply run the following code to install the package:</p> <pre><code>pip install jaxquantum\n</code></pre>"},{"location":"getting_started/installation.html#install-with-gpu-support-linux","title":"Install with GPU support (Linux)","text":"<p>For linux users who wish to enable Nvidia GPU support, here are some steps (ref):</p> <ol> <li>Make sure you NVIDIA drivers by running:    <code>cat /proc/driver/nvidia/version</code> or <code>sudo ubuntu-drivers list</code></li> <li>If your driver version is &gt;= 525.60.13 then run:    <code>pip install --upgrade \"jax[cuda12_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html</code> otherwise, use <code>cuda11_pip</code></li> <li>Test that GPU support is enabled:</li> <li>Enjoy!</li> </ol> <p>Notes: If you receive this error:</p> <pre><code>2024-02-27 14:10:45.052355: W external/xla/xla/service/gpu/nvptx_compiler.cc:742] The NVIDIA driver's CUDA version is 12.0 which is older than the ptxas CUDA version (12.3.107). Because the driver is older than the ptxas version, XLA is disabling parallel compilation, which may slow down compilation. You should update your NVIDIA driver or use the NVIDIA-provided CUDA forward compatibility packages.\n</code></pre> <p>Then, you should update your NVIDIA driver by running:</p> <pre><code>conda install cuda -c nvidia\n</code></pre> <p>If you receive this error: <code>CUDA backend failed to initialize: jaxlib/cuda/versions_helpers.cc:98: operation cuInit(0) failed: CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)</code></p> <p>Try rebooting or running: <code>sudo reboot now</code></p>"},{"location":"reference/summary.html","title":"Summary","text":"<ul> <li>jaxquantum<ul> <li>core<ul> <li>conversions</li> <li>operators</li> <li>qarray</li> <li>settings</li> <li>solvers</li> <li>visualization</li> </ul> </li> <li>utils<ul> <li>utils</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/jaxquantum/index.html","title":"jaxquantum","text":"<p>jaxquantum</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.basis","title":"<code>basis(N, k)</code>","text":"<p>Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert space dimension</p> required <code>k</code> <code>int</code> <p>fock number</p> required <p>Returns:</p> Type Description <p>Fock State |k&gt;</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def basis(N: int, k: int):\n    \"\"\"Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.\n\n    Args:\n        N: Hilbert space dimension\n        k: fock number\n\n    Returns:\n        Fock State |k&gt;\n    \"\"\"\n    return Qarray.create(one_hot(k, N).reshape(N, 1))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.basis_like","title":"<code>basis_like(A, ks)</code>","text":"<p>Creates a |k&gt; (i.e. fock state) ket with the same space dims as A.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Qarray</code> <p>state or operator.</p> required <code>k</code> <p>fock number.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Fock State |k&gt; with the same space dims as A.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def basis_like(A: Qarray, ks: List[int]) -&gt; Qarray:\n    \"\"\"Creates a |k&gt; (i.e. fock state) ket with the same space dims as A.\n\n    Args:\n        A: state or operator.\n        k: fock number.\n\n    Returns:\n        Fock State |k&gt; with the same space dims as A.\n    \"\"\"\n    space_dims = A.space_dims \n    assert len(space_dims) == len(ks), \"len(ks) must be equal to len(space_dims)\"\n\n    kets = []\n    for j, k in enumerate(ks):\n        kets.append(basis(space_dims[j], k))\n    return tensor(*kets)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.batch_dag_data","title":"<code>batch_dag_data(op)</code>","text":"<p>Conjugate transpose.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>Array</code> <p>operator</p> required <p>Returns:</p> Type Description <code>Array</code> <p>conjugate of op, and transposes last two axes</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def batch_dag_data(op: Array) -&gt; Array:\n    \"\"\"Conjugate transpose.\n\n    Args:\n        op: operator\n\n    Returns:\n        conjugate of op, and transposes last two axes\n    \"\"\"\n    return jnp.moveaxis(\n        jnp.conj(op), -1, -2\n    )  # transposes last two axes, good for batching\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.calc_expect","title":"<code>calc_expect(op, states)</code>","text":"<p>Calculate expectation value of an operator given a list of states.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>Qarray</code> <p>operator</p> required <code>states</code> <code>List[Qarray]</code> <p>list of states</p> required <p>Returns:</p> Type Description <code>Array</code> <p>list of expectation values</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def calc_expect(op: Qarray, states: List[Qarray]) -&gt; Array:\n    \"\"\"Calculate expectation value of an operator given a list of states.\n\n    Args:\n        op: operator\n        states: list of states\n\n    Returns:\n        list of expectation values\n    \"\"\"\n\n    op = op.data\n    is_dm = states[0].is_dm()\n    states = jqts2jnps(states)\n\n    def calc_expect_ket_single(state: Array):\n        return (jnp.conj(state).T @ op @ state)[0][0]\n\n    def calc_expect_dm_single(state: Array):\n        return jnp.trace(op @ state)\n\n    if is_dm:\n        return vmap(calc_expect_dm_single)(states)\n    else:\n        return vmap(calc_expect_ket_single)(states)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.coherent","title":"<code>coherent(N, \u03b1)</code>","text":"<p>Coherent state.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert Space Size.</p> required <code>\u03b1</code> <code>complex</code> <p>coherent state amplitude.</p> required Return <p>Coherent state |\u03b1\u27e9.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def coherent(N: int, \u03b1: complex) -&gt; Qarray:\n    \"\"\"Coherent state.\n\n    Args:\n        N: Hilbert Space Size.\n        \u03b1: coherent state amplitude.\n\n    Return:\n        Coherent state |\u03b1\u27e9.\n    \"\"\"\n    return displace(N, \u03b1) @ basis(N, 0)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.comb","title":"<code>comb(N, k)</code>","text":"<p>NCk</p>"},{"location":"reference/jaxquantum/index.html#jaxquantum.comb--todo-replace-with-jspspecialcomb-once-issue-is-closed","title":"TODO: replace with jsp.special.comb once issue is closed:","text":"<p>https://github.com/google/jax/issues/9709</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>total items</p> required <code>k</code> required <p>Returns:</p> Name Type Description <code>NCk</code> <p>N choose k</p> Source code in <code>jaxquantum/utils/utils.py</code> <pre><code>def comb(N, k):\n    \"\"\"\n    NCk\n\n    #TODO: replace with jsp.special.comb once issue is closed:\n    https://github.com/google/jax/issues/9709\n\n    Args:\n        N: total items\n        k: # of items to choose\n\n    Returns:\n        NCk: N choose k\n    \"\"\"\n    one = 1\n    N_plus_1 = lax.add(N, one)\n    k_plus_1 = lax.add(k, one)\n    return lax.exp(\n        lax.sub(\n            gammaln(N_plus_1), lax.add(gammaln(k_plus_1), gammaln(lax.sub(N_plus_1, k)))\n        )\n    )\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.comb--of-items-to-choose","title":"of items to choose","text":""},{"location":"reference/jaxquantum/index.html#jaxquantum.cosm","title":"<code>cosm(qarr)</code>","text":"<p>Matrix cosine wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix cosine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def cosm(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Matrix cosine wrapper.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        matrix cosine\n    \"\"\"\n    dims = qarr.dims\n    data = cosm_data(qarr.data)\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.cosm_data","title":"<code>cosm_data(data, **kwargs)</code>","text":"<p>Matrix cosine wrapper.</p> <p>Returns:</p> Type Description <code>Array</code> <p>matrix cosine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def cosm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix cosine wrapper.\n\n    Returns:\n        matrix cosine\n    \"\"\"\n    return (expm_data(1j*data) + expm_data(-1j*data))/2 \n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.create","title":"<code>create(N)</code>","text":"<p>creation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>creation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def create(N) -&gt; Qarray:\n    \"\"\"creation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        creation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=-1))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.dag","title":"<code>dag(qarr)</code>","text":"<p>Conjugate transpose.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>conjugate transpose of qarr</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def dag(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Conjugate transpose.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        conjugate transpose of qarr\n    \"\"\"\n    data = jnp.conj(qarr.data).T\n    dims = deepcopy(qarr.dims)\n    dims = dims[::-1]\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.dag_data","title":"<code>dag_data(op)</code>","text":"<p>Conjugate transpose.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>Array</code> <p>operator</p> required <p>Returns:</p> Type Description <code>Array</code> <p>conjugate of op, and transposes last two axes</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def dag_data(op: Array) -&gt; Array:\n    \"\"\"Conjugate transpose.\n\n    Args:\n        op: operator\n\n    Returns:\n        conjugate of op, and transposes last two axes\n    \"\"\"\n    return jnp.conj(op.T) \n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.destroy","title":"<code>destroy(N)</code>","text":"<p>annihilation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>annilation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def destroy(N) -&gt; Qarray:\n    \"\"\"annihilation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        annilation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=1))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.displace","title":"<code>displace(N, \u03b1)</code>","text":"<p>Displacement operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space Size</p> required <code>\u03b1</code> <p>Phase space displacement</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Displace operator D(\u03b1)</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def displace(N, \u03b1) -&gt; Qarray:\n    \"\"\"Displacement operator\n\n    Args:\n        N: Hilbert Space Size\n        \u03b1: Phase space displacement\n\n    Returns:\n        Displace operator D(\u03b1)\n    \"\"\"\n    a = destroy(N)\n    return (\u03b1 * a.dag() - jnp.conj(\u03b1) * a).expm()\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.eigenenergies","title":"<code>eigenenergies(qarr)</code>","text":"<p>Eigenvalues of a quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>eigenvalues</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def eigenenergies(qarr: Qarray) -&gt; Array:\n    \"\"\"Eigenvalues of a quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        eigenvalues\n    \"\"\"\n\n    evals = jnp.linalg.eigvalsh(qarr.data)\n    return evals\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.eigenstates","title":"<code>eigenstates(qarr)</code>","text":"<p>Eigenstates of a quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>eigenvalues and eigenstates</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def eigenstates(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Eigenstates of a quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        eigenvalues and eigenstates\n    \"\"\"\n\n    evals, evecs = jnp.linalg.eigh(qarr.data)\n    idxs_sorted = jnp.argsort(evals)\n\n    dims = ket_from_op_dims(qarr.dims)\n\n    evals =  evals[idxs_sorted]\n    evecs = evecs[:, idxs_sorted]\n    evecs = [Qarray.create(arr, dims=dims) for arr in evecs]\n\n    return evals, evecs\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.expm","title":"<code>expm(qarr, **kwargs)</code>","text":"<p>Matrix exponential wrapper.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix exponential</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def expm(qarr: Qarray, **kwargs) -&gt; Qarray:\n    \"\"\"Matrix exponential wrapper.\n\n    Returns:\n        matrix exponential\n    \"\"\"\n    dims = qarr.dims\n    data = expm_data(qarr.data, **kwargs)\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.expm_data","title":"<code>expm_data(data, **kwargs)</code>","text":"<p>Matrix exponential wrapper.</p> <p>Returns:</p> Type Description <code>Array</code> <p>matrix exponential</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def expm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix exponential wrapper.\n\n    Returns:\n        matrix exponential\n    \"\"\"\n    return jsp.linalg.expm(data, **kwargs)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.extract_dims","title":"<code>extract_dims(arr, dims=None)</code>","text":"<p>Extract dims from a JAX array or Qarray.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Array</code> <p>JAX array or Qarray.</p> required <code>dims</code> <code>Optional[Union[DIMS_TYPE, List[int]]]</code> <p>Qarray dims.</p> <code>None</code> <p>Returns:</p> Type Description <p>Qarray dims.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def extract_dims(arr: Array, dims: Optional[Union[DIMS_TYPE, List[int]]] = None):\n    \"\"\"Extract dims from a JAX array or Qarray.\n\n    Args:\n        arr: JAX array or Qarray.\n        dims: Qarray dims.\n\n    Returns:\n        Qarray dims.\n    \"\"\"\n    if isinstance(dims[0], Number):\n        is_op = len(arr.shape) == 2 and arr.shape[0] == arr.shape[1]\n        if is_op:\n            dims = [dims, dims]\n        else:\n            dims = [dims, [1] * len(dims)] # defaults to ket \n    return dims\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.hadamard","title":"<code>hadamard()</code>","text":"<p>H</p> <p>Returns:</p> Name Type Description <code>H</code> <code>Qarray</code> <p>Hadamard gate</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def hadamard() -&gt; Qarray:\n    \"\"\"H\n\n    Returns:\n        H: Hadamard gate\n    \"\"\"\n    return Qarray.create(jnp.array([[1, 1], [1, -1]]) / jnp.sqrt(2))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.identity","title":"<code>identity(*args, **kwargs)</code>","text":"<p>Identity matrix.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Identity matrix.\n\n    Returns:\n        Identity matrix.\n    \"\"\"\n    return Qarray.create(jnp.eye(*args, **kwargs))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.identity_like","title":"<code>identity_like(A)</code>","text":"<p>Identity matrix with the same shape as A.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <p>Matrix.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix with the same shape as A.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity_like(A) -&gt; Qarray:\n    \"\"\"Identity matrix with the same shape as A.\n\n    Args:\n        A: Matrix.\n\n    Returns:\n        Identity matrix with the same shape as A.\n    \"\"\"\n    space_dims = A.space_dims \n    total_dim = prod(space_dims)\n    return Qarray.create(jnp.eye(total_dim, total_dim), dims=[space_dims, space_dims])\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.jnp2jqt","title":"<code>jnp2jqt(arr, dims=None)</code>","text":"<p>JAX array -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jnp_obj</code> <p>JAX array.</p> required <code>dims</code> <code>Optional[Union[DIMS_TYPE, List[int]]]</code> <p>Qarray dims.</p> <code>None</code> <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jnp2jqt(arr: Array, dims: Optional[Union[DIMS_TYPE, List[int]]] = None):\n    \"\"\"JAX array -&gt; QuTiP state.\n\n    Args:\n        jnp_obj: JAX array.\n        dims: Qarray dims.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n    dims = extract_dims(arr, dims) if dims is not None else None\n    return Qarray.create(arr, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.jnps2jqts","title":"<code>jnps2jqts(arrs, dims=None)</code>","text":"<p>JAX array -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jnp_obj</code> <p>JAX array.</p> required <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jnps2jqts(arrs: Array, dims: Optional[DIMS_TYPE] = None):\n    \"\"\"JAX array -&gt; QuTiP state.\n\n    Args:\n        jnp_obj: JAX array.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n\n    dims = extract_dims(arrs[0], dims) if dims is not None else None\n    return [Qarray.create(arr, dims=dims) for arr in arrs]\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.jqt2qt","title":"<code>jqt2qt(jqt_obj)</code>","text":"<p>Qarray -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jqt_obj</code> <p>Qarray.</p> required <code>dims</code> <p>QuTiP dims.</p> required <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jqt2qt(jqt_obj):\n    \"\"\"Qarray -&gt; QuTiP state.\n\n    Args:\n        jqt_obj: Qarray.\n        dims: QuTiP dims.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n    if isinstance(jqt_obj, Qobj) or jqt_obj is None:\n        return jqt_obj\n\n    return Qobj(np.array(jqt_obj.data), dims=jqt_obj.dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.jqts2jnps","title":"<code>jqts2jnps(qarrs)</code>","text":"<p>QuTiP state -&gt; JAX array.</p> <p>Parameters:</p> Name Type Description Default <code>qt_obj</code> <p>QuTiP state.</p> required <p>Returns:</p> Type Description <p>JAX array.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jqts2jnps(qarrs: Qarray):\n    \"\"\"QuTiP state -&gt; JAX array.\n\n    Args:\n        qt_obj: QuTiP state.\n\n    Returns:\n        JAX array.\n    \"\"\"\n    return jnp.array([qarr.data for qarr in qarrs])\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.ket2dm","title":"<code>ket2dm(qarr)</code>","text":"<p>Turns ket into density matrix. Does nothing if already operator.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>qarr</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Density matrix</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def ket2dm(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Turns ket into density matrix.\n    Does nothing if already operator.\n\n    Args:\n        qarr (Qarray): qarr\n\n    Returns:\n        Density matrix\n    \"\"\"\n\n    if qarr.qtype == Qtypes.oper:\n        return qarr\n\n    if qarr.qtype == Qtypes.bra:\n        qarr = qarr.dag()\n\n    return qarr @ qarr.dag()\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.mesolve","title":"<code>mesolve(\u03c10, t_list, c_ops=None, H0=None, Ht=None, solver_options=None)</code>","text":"<p>Quantum Master Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>\u03c10</code> <code>Qarray</code> <p>initial state, must be a density matrix. For statevector evolution, please use sesolve.</p> required <code>t_list</code> <code>Array</code> <p>time list</p> required <code>c_ops</code> <code>Optional[List[Qarray]]</code> <p>list of collapse operators</p> <code>None</code> <code>H0</code> <code>Optional[Qarray]</code> <p>time independent Hamiltonian. If H0 is not None, it will override Ht.</p> <code>None</code> <code>Ht</code> <code>Optional[Callable[[float], Qarray]]</code> <p>time dependent Hamiltonian function.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def mesolve(\n    \u03c10: Qarray,\n    t_list: Array,\n    c_ops: Optional[List[Qarray]] = None,\n    H0: Optional[Qarray] = None,\n    Ht: Optional[Callable[[float], Qarray]] = None,\n    solver_options: Optional[SolverOptions] = None\n):\n    \"\"\"Quantum Master Equation solver.\n\n    Args:\n        \u03c10: initial state, must be a density matrix. For statevector evolution, please use sesolve.\n        t_list: time list\n        c_ops: list of collapse operators\n        H0: time independent Hamiltonian. If H0 is not None, it will override Ht.\n        Ht: time dependent Hamiltonian function.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    c_ops = c_ops or []\n\n    if len(c_ops) == 0 and \u03c10.qtype != Qtypes.oper:\n        logging.warning(\n            \"Consider using `jqt.sesolve()` instead, as `c_ops` is an empty list and the initial state is not a density matrix.\"\n        )\n\n    \u03c10 = \u03c10.to_dm()\n    dims = \u03c10.dims\n    \u03c10 = \u03c10.data\n\n    c_ops = [c_op.data for c_op in c_ops]\n    H0 = jnp.asarray(H0.data) if H0 is not None else None\n    Ht_data = lambda t: Ht(t).data if Ht is not None else None\n\n    ys = mesolve_data(\u03c10, t_list, c_ops, H0, Ht_data, solver_options)\n\n    return jnps2jqts(ys, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.mesolve_data","title":"<code>mesolve_data(\u03c10, t_list, c_ops=None, H0=None, Ht=None, solver_options=None)</code>","text":"<p>Quantum Master Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>\u03c10</code> <code>Array</code> <p>initial state, must be a density matrix. For statevector evolution, please use sesolve.</p> required <code>t_list</code> <code>Array</code> <p>time list</p> required <code>c_ops</code> <code>Optional[List[Array]]</code> <p>list of collapse operators</p> <code>None</code> <code>H0</code> <code>Optional[Array]</code> <p>time independent Hamiltonian. If H0 is not None, it will override Ht.</p> <code>None</code> <code>Ht</code> <code>Optional[Callable[[float], Array]]</code> <p>time dependent Hamiltonian function.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def mesolve_data(\n    \u03c10: Array,\n    t_list: Array,\n    c_ops: Optional[List[Array]] = None,\n    H0: Optional[Array] = None,\n    Ht: Optional[Callable[[float], Array]] = None,\n    solver_options: Optional[SolverOptions] = None\n):\n    \"\"\"Quantum Master Equation solver.\n\n    Args:\n        \u03c10: initial state, must be a density matrix. For statevector evolution, please use sesolve.\n        t_list: time list\n        c_ops: list of collapse operators\n        H0: time independent Hamiltonian. If H0 is not None, it will override Ht.\n        Ht: time dependent Hamiltonian function.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    c_ops = c_ops or []\n\n    if len(c_ops) == 0:\n        logging.warning(\n            \"Consider using `jqt.sesolve()` instead, as `c_ops` is an empty list and the initial state is not a density matrix.\"\n        )\n\n    \u03c10 = \u03c10 + 0.0j\n\n    c_ops = jnp.asarray([c_op for c_op in c_ops]) + 0.0j\n    H0 = H0 + 0.0j if H0 is not None else None\n\n    def f(\n        t: float,\n        rho: Array,\n        args: Array,\n    ):\n        H0_val = args[0]\n        c_ops_val = args[1]\n\n        if H0_val is not None:\n            H = H0_val  # use H0 if given\n        else:\n            H = Ht(t)  # type: ignore\n            H = H + 0.0j\n\n        rho_dot = -1j * (H @ rho - rho @ H)\n\n        for op in c_ops_val:\n            rho_dot += spre(op)(rho)\n\n        return rho_dot\n\n\n    sol = solve(\u03c10, f, t_list, [H0, c_ops], solver_options=solver_options)\n\n    return sol.ys\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.num","title":"<code>num(N)</code>","text":"<p>Number operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>number operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def num(N) -&gt; Qarray:\n    \"\"\"Number operator\n\n    Args:\n        N: Hilbert Space size\n\n    Returns:\n        number operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.arange(N)))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.op2jqts","title":"<code>op2jqts(op, cols=True)</code>","text":"<p>QuTiP operator -&gt; JAX array.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>Qarray</code> <p>QuTiP operator.</p> required <p>Returns:</p> Type Description <p>JAX array.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def op2jqts(op: Qarray, cols=True):\n    \"\"\"QuTiP operator -&gt; JAX array.\n\n    Args:\n        op: QuTiP operator.\n\n    Returns:\n        JAX array.\n    \"\"\"\n    if op.qtype != Qtypes.oper:\n        raise ValueError(\"Input must be a QuTiP operator.\")\n\n    space_dims = op.space_dims\n    ones = [1] * len(space_dims)\n\n    if cols:\n        return [Qarray.create(op.data[i,:], dims=[space_dims, ones]) for i in range(op.data.shape[0])]\n    else:\n        return [Qarray.create(op.data[:,i][jnp.newaxis,...], dims=[ones, space_dims]) for i in range(op.data.shape[1])]\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.plot_qp","title":"<code>plot_qp(state, pts, ax=None, contour=True, qp_type=WIGNER)</code>","text":"<p>Plot quasi-probability distribution.</p> <p>TODO: decouple this from qutip.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>statevector</p> required <code>pts</code> <p>points to evaluate quasi-probability distribution on</p> required <code>dim</code> <p>dimensions of state</p> required <code>ax</code> <p>matplotlib axis to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>qp_type</code> <p>type of quasi probability distribution (\"wigner\", \"qfunc\")</p> <code>WIGNER</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_qp(state, pts, ax=None, contour=True, qp_type=WIGNER):\n    \"\"\"Plot quasi-probability distribution.\n\n    TODO: decouple this from qutip.\n\n    Args:\n        state: statevector\n        pts: points to evaluate quasi-probability distribution on\n        dim: dimensions of state\n        ax: matplotlib axis to plot on\n        contour: make the plot use contouring\n        qp_type: type of quasi probability distribution (\"wigner\", \"qfunc\")\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    pts = np.array(pts)\n    state = jqt2qt(state)\n    if ax is None:\n        _, ax = plt.subplots(1, figsize=(4, 3), dpi=200)\n    # fig = ax.get_figure()\n\n    if qp_type == WIGNER:\n        vmin = -1\n        vmax = 1\n        scale = np.pi / 2\n        cmap = \"seismic\"\n    elif qp_type == QFUNC:\n        vmin = 0\n        vmax = 1\n        scale = np.pi\n        cmap = \"jet\"\n\n    QP = scale * getattr(qt, qp_type)(state, pts, pts, g=2)\n\n    if contour:\n        im = ax.contourf(\n            pts,\n            pts,\n            QP,\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            levels=np.linspace(vmin, vmax, 101),\n        )\n    else:\n        im = ax.pcolormesh(\n            pts,\n            pts,\n            QP,\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n        )\n    ax.axhline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n    ax.axvline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n    ax.grid()\n    ax.set_aspect(\"equal\", adjustable=\"box\")\n    return im\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.powm","title":"<code>powm(qarr, n)</code>","text":"<p>Matrix power.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <code>n</code> <code>int</code> <p>power</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix power</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def powm(qarr: Qarray, n: int) -&gt; Qarray:\n    \"\"\"Matrix power.\n\n    Args:\n        qarr (Qarray): quantum array\n        n (int): power\n\n    Returns:\n        matrix power\n    \"\"\"\n    data = jnp.linalg.matrix_power(qarr.data, n)\n    return Qarray.create(data, dims=qarr.dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.propagator","title":"<code>propagator(H, t, solver_options=None)</code>","text":"<p>Generate the propagator for a time dependent Hamiltonian. </p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Qarray or callable</code> <p>A Qarray static Hamiltonian OR a function that takes a time argument and returns a Hamiltonian. </p> required <code>ts</code> <code>float or Array</code> <p>A single time point or an Array of time points.</p> required <p>Returns:</p> Type Description <p>Qarray or List[Qarray]:  The propagator for the Hamiltonian at time t. OR a list of propagators for the Hamiltonian at each time in t.</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def propagator(\n    H: Union[Qarray, Callable[[float], Qarray]],\n    t: Union[float, Array],\n    solver_options=None\n):\n    \"\"\" Generate the propagator for a time dependent Hamiltonian. \n\n    Args:\n        H (Qarray or callable): \n            A Qarray static Hamiltonian OR\n            a function that takes a time argument and returns a Hamiltonian. \n        ts (float or Array): \n            A single time point or\n            an Array of time points.\n\n    Returns:\n        Qarray or List[Qarray]: \n            The propagator for the Hamiltonian at time t.\n            OR a list of propagators for the Hamiltonian at each time in t.\n\n    \"\"\"\n\n    t_is_scalar = robust_isscalar(t)\n\n    if isinstance(H, Qarray):\n        dims = H.dims \n        if t_is_scalar:\n            if t == 0:\n                return identity_like(H)\n\n            return jnp2jqt(propagator_0_data(H.data,t), dims=dims)\n        else:\n            f = lambda t: propagator_0_data(H.data,t)\n            return jnps2jqts(vmap(f)(t), dims)\n    else:\n        dims = H(0.0).dims\n        H_data = lambda t: H(t).data\n        if t_is_scalar:\n            if t == 0:\n                return identity_like(H(0.0))\n\n            ts = jnp.linspace(0,t,2)\n            return jnp2jqt(\n                propagator_t_data(H_data, ts, solver_options=solver_options)[1],\n                dims=dims\n            )\n        else:\n            ts = t \n            U_props = propagator_t_data(H_data, ts, solver_options=solver_options)\n            return jnps2jqts(U_props, dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.propagator_0_data","title":"<code>propagator_0_data(H0, t)</code>","text":"<p>Generate the propagator for a time independent Hamiltonian. </p> <p>Parameters:</p> Name Type Description Default <code>H0</code> <code>Qarray</code> <p>The Hamiltonian.</p> required <p>Returns:</p> Name Type Description <code>Qarray</code> <p>The propagator for the time independent Hamiltonian.</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def propagator_0_data(\n    H0: Array,\n    t: float\n):\n    \"\"\" Generate the propagator for a time independent Hamiltonian. \n\n    Args:\n        H0 (Qarray): The Hamiltonian.\n\n    Returns:\n        Qarray: The propagator for the time independent Hamiltonian.\n    \"\"\"\n    return jsp.linalg.expm(-1j * H0 * t)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.propagator_t_data","title":"<code>propagator_t_data(Ht, ts, solver_options=None)</code>","text":"<p>Generate the propagator for a time dependent Hamiltonian. </p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>float</code> <p>The final time of the propagator.  Warning: Do not send in t. In this case, just do exp(-1j*Ht(0.0)).</p> required <code>Ht</code> <code>callable</code> <p>A function that takes a time argument and returns a Hamiltonian. </p> required <code>solver_options</code> <code>dict</code> <p>Options to pass to the solver.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Qarray</code> <p>The propagator for the time dependent Hamiltonian for the time range [0, t_final].</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def propagator_t_data(\n    Ht: Callable[[float], Array],\n    ts: Array, \n    solver_options=None\n):\n    \"\"\" Generate the propagator for a time dependent Hamiltonian. \n\n    Args:\n        ts (float): The final time of the propagator. \n            Warning: Do not send in t. In this case, just do exp(-1j*Ht(0.0)).\n        Ht (callable): A function that takes a time argument and returns a Hamiltonian. \n        solver_options (dict): Options to pass to the solver.\n\n    Returns:\n        Qarray: The propagator for the time dependent Hamiltonian for the time range [0, t_final].\n    \"\"\"\n    N = Ht(0).shape[0]\n    basis_states = jnp.eye(N)\n\n    def propogate_state(initial_state):\n        return sesolve_data(initial_state, ts, Ht=Ht, solver_options=solver_options)\n\n    U_prop = vmap(propogate_state)(basis_states)\n    U_prop = U_prop.transpose(1,0,2) # move time axis to the front\n    return U_prop\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.ptrace","title":"<code>ptrace(qarr, indx)</code>","text":"<p>Partial Trace.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <p>density matrix</p> required <code>indx</code> <p>index of quantum object to keep, rest will be partial traced out</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>partial traced out density matrix</p> <p>TODO: Fix weird tracing errors that arise with reshape</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def ptrace(qarr: Qarray, indx) -&gt; Qarray:\n    \"\"\"Partial Trace.\n\n    Args:\n        rho: density matrix\n        indx: index of quantum object to keep, rest will be partial traced out\n\n    Returns:\n        partial traced out density matrix\n\n    TODO: Fix weird tracing errors that arise with reshape\n    \"\"\"\n\n    qarr = ket2dm(qarr)\n    rho = qarr.shaped_data\n    dims = qarr.dims\n\n    Nq = len(dims[0])\n\n    indxs = [indx, indx + Nq]\n    for j in range(Nq):\n        if j == indx:\n            continue\n        indxs.append(j)\n        indxs.append(j + Nq)\n    rho = rho.transpose(indxs)\n\n    for j in range(Nq - 1):\n        rho = jnp.trace(rho, axis1=2, axis2=3)\n\n    return Qarray.create(rho)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.qt2jqt","title":"<code>qt2jqt(qt_obj, dtype=jnp.complex128)</code>","text":"<p>QuTiP state -&gt; Qarray.</p> <p>Parameters:</p> Name Type Description Default <code>qt_obj</code> <p>QuTiP state.</p> required <code>dtype</code> <p>JAX dtype.</p> <code>complex128</code> <p>Returns:</p> Type Description <p>Qarray.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def qt2jqt(qt_obj, dtype=jnp.complex128):\n    \"\"\"QuTiP state -&gt; Qarray.\n\n    Args:\n        qt_obj: QuTiP state.\n        dtype: JAX dtype.\n\n    Returns:\n        Qarray.\n    \"\"\"\n    if isinstance(qt_obj, Qarray) or qt_obj is None:\n        return qt_obj\n    return Qarray.create(jnp.array(qt_obj, dtype=dtype), dims=qt_obj.dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.sesolve","title":"<code>sesolve(\u03c8, t_list, H0=None, Ht=None, solver_options=None)</code>","text":"<p>Schr\u00f6dinger Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>\u03c8</code> <code>Qarray</code> <p>initial statevector</p> required <code>t_list</code> <code>Array</code> <p>time list</p> required <code>H0</code> <code>Optional[Qarray]</code> <p>time independent Hamiltonian. If H0 is not None, it will override Ht.</p> <code>None</code> <code>Ht</code> <code>Optional[Callable[[float], Qarray]]</code> <p>time dependent Hamiltonian function.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def sesolve(\n    \u03c8: Qarray,\n    t_list: Array,\n    H0: Optional[Qarray] = None,\n    Ht: Optional[Callable[[float], Qarray]] = None,\n    solver_options: Optional[SolverOptions] = None,\n):\n    \"\"\"Schr\u00f6dinger Equation solver.\n\n    Args:\n        \u03c8: initial statevector\n        t_list: time list\n        H0: time independent Hamiltonian. If H0 is not None, it will override Ht.\n        Ht: time dependent Hamiltonian function.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    if \u03c8.qtype == Qtypes.oper:\n        raise ValueError(\n            \"Please use `jqt.mesolve` for initial state inputs in density matrix form.\"\n        )\n\n    \u03c8 = \u03c8.to_ket()\n\n    dims = \u03c8.dims\n\n    \u03c8 = \u03c8.data \n    H0 = H0.data if H0 is not None else None\n    Ht_data = lambda t: Ht(t).data if Ht is not None else None\n\n    ys = sesolve_data(\u03c8, t_list, H0, Ht_data, solver_options)\n\n    return jnps2jqts(ys, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.sesolve_data","title":"<code>sesolve_data(\u03c8, t_list, H0=None, Ht=None, solver_options=None)</code>","text":"<p>Schr\u00f6dinger Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>\u03c8</code> <code>Array</code> <p>initial statevector</p> required <code>t_list</code> <code>Array</code> <p>time list</p> required <code>H0</code> <code>Optional[Array]</code> <p>time independent Hamiltonian. If H0 is not None, it will override Ht.</p> <code>None</code> <code>Ht</code> <code>Optional[Callable[[float], Array]]</code> <p>time dependent Hamiltonian function.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def sesolve_data(\n    \u03c8: Array,\n    t_list: Array,\n    H0: Optional[Array] = None,\n    Ht: Optional[Callable[[float], Array]] = None,\n    solver_options: Optional[SolverOptions] = None,\n):\n    \"\"\"Schr\u00f6dinger Equation solver.\n\n    Args:\n        \u03c8: initial statevector\n        t_list: time list\n        H0: time independent Hamiltonian. If H0 is not None, it will override Ht.\n        Ht: time dependent Hamiltonian function.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    \u03c8 = \u03c8 + 0.0j\n    H0 = H0 + 0.0j if H0 is not None else None\n    solver_options = solver_options or {}\n\n    def f(\n        t: float,\n        \u03c8\u209c: Array,\n        args: Array,\n    ):\n        H0_val = args[0]\n\n        if H0_val is not None:\n            H = H0_val  # use H0 if given\n        else:\n            H = Ht(t)  # type: ignore\n        # print(\"H\", H.shape)\n        # print(\"psit\", \u03c8\u209c.shape)\n        \u03c8\u209c_dot = -1j * (H @ \u03c8\u209c)\n\n        return \u03c8\u209c_dot\n\n\n    sol = solve(\u03c8, f, t_list, [H0], solver_options=solver_options)\n    return sol.ys\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.sigmam","title":"<code>sigmam()</code>","text":"<p>\u03c3-</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3- Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmam() -&gt; Qarray:\n    \"\"\"\u03c3-\n\n    Returns:\n        \u03c3- Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 0.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.sigmap","title":"<code>sigmap()</code>","text":"<p>\u03c3+</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3+ Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmap() -&gt; Qarray:\n    \"\"\"\u03c3+\n\n    Returns:\n        \u03c3+ Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [0.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.sigmax","title":"<code>sigmax()</code>","text":"<p>\u03c3x</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3x Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmax() -&gt; Qarray:\n    \"\"\"\u03c3x\n\n    Returns:\n        \u03c3x Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.sigmay","title":"<code>sigmay()</code>","text":"<p>\u03c3y</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3y Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmay() -&gt; Qarray:\n    \"\"\"\u03c3y\n\n    Returns:\n        \u03c3y Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, -1.0j], [1.0j, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.sigmaz","title":"<code>sigmaz()</code>","text":"<p>\u03c3z</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3z Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmaz() -&gt; Qarray:\n    \"\"\"\u03c3z\n\n    Returns:\n        \u03c3z Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[1.0, 0.0], [0.0, -1.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.sinm_data","title":"<code>sinm_data(data, **kwargs)</code>","text":"<p>Matrix sine wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>matrix</p> required <p>Returns:</p> Type Description <code>Array</code> <p>matrix sine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def sinm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix sine wrapper.\n\n    Args:\n        data: matrix\n\n    Returns:\n        matrix sine\n    \"\"\"\n    return (expm_data(1j*data) - expm_data(-1j*data))/(2j)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.solve","title":"<code>solve(\u03c10, f, t_list, args, solver_options=None)</code>","text":"<p>Gets teh desired solver from diffrax.</p> <p>Parameters:</p> Name Type Description Default <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>dictionary with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>solution</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def solve(\u03c10, f, t_list, args, solver_options: Optional[SolverOptions] = None):\n    \"\"\" Gets teh desired solver from diffrax.\n\n    Args:\n        solver_options: dictionary with solver options\n\n    Returns:\n        solution \n    \"\"\"\n\n    # f and ts\n    term = ODETerm(f)\n    saveat = SaveAt(ts=t_list)\n\n    # solver \n    solver_options = solver_options or SolverOptions.create()\n\n    solver_name = solver_options.solver\n    solver = getattr(diffrax, solver_name)()\n    stepsize_controller = PIDController(rtol=1e-6, atol=1e-6)\n\n    # solve!\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', UserWarning) # NOTE: suppresses complex dtype warning in diffrax\n        sol = diffeqsolve(\n            term,\n            solver,\n            t0=t_list[0],\n            t1=t_list[-1],\n            dt0=t_list[1] - t_list[0],\n            y0=\u03c10,\n            saveat=saveat,\n            stepsize_controller=stepsize_controller,\n            args=args,\n            max_steps=solver_options.max_steps,\n            progress_meter=CustomProgressMeter() if solver_options.progress_meter else NoProgressMeter(),\n        )   \n\n    return sol\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.spre","title":"<code>spre(op)</code>","text":"<p>Superoperator generator.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>Array</code> <p>operator to be turned into a superoperator</p> required <p>Returns:</p> Type Description <code>Callable[[Array], Array]</code> <p>superoperator function</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def spre(op: Array) -&gt; Callable[[Array], Array]:\n    \"\"\"Superoperator generator.\n\n    Args:\n        op: operator to be turned into a superoperator\n\n    Returns:\n        superoperator function\n    \"\"\"\n    op_dag = op.conj().T\n    return lambda rho: 0.5 * (\n        2 * op @ rho @ op_dag - rho @ op_dag @ op - op_dag @ op @ rho\n    )\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.tensor","title":"<code>tensor(*args, **kwargs)</code>","text":"<p>Tensor product.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Qarray</code> <p>tensors to take the product of</p> <code>()</code> <p>Returns:</p> Type Description <code>Qarray</code> <p>Tensor product of given tensors</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tensor(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Tensor product.\n\n    Args:\n        *args (Qarray): tensors to take the product of\n\n    Returns:\n        Tensor product of given tensors\n\n    \"\"\"\n    data = args[0].data\n    dims = deepcopy(args[0].dims)\n    for arg in args[1:]:\n        data = jnp.kron(data, arg.data)\n        dims[0] += arg.dims[0]\n        dims[1] += arg.dims[1]\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.tr","title":"<code>tr(qarr, **kwargs)</code>","text":"<p>Full trace.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array    </p> required <p>Returns:</p> Type Description <code>complex128</code> <p>Full trace.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tr(qarr: Qarray, **kwargs) -&gt; jnp.complex128:\n    \"\"\"Full trace.\n\n    Args:\n        qarr (Qarray): quantum array    \n\n    Returns:\n        Full trace.\n    \"\"\"\n    return trace(qarr, **kwargs)\n</code></pre>"},{"location":"reference/jaxquantum/index.html#jaxquantum.unit","title":"<code>unit(qarr)</code>","text":"<p>Normalize the quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Normalized quantum array</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def unit(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Normalize the quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        Normalized quantum array\n    \"\"\"\n    data = qarr.data\n\n    if qarr.qtype == Qtypes.oper:\n        evals, _ = jnp.linalg.eigh(data @ jnp.conj(data).T)\n        rho_norm = jnp.sum(jnp.sqrt(jnp.abs(evals)))\n        data = data / rho_norm\n    elif qarr.qtype in [Qtypes.ket, Qtypes.bra]:\n        data = data / jnp.linalg.norm(data)\n\n    return Qarray.create(data, dims=qarr.dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html","title":"core","text":"<p>Quantum Tooling</p>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.basis","title":"<code>basis(N, k)</code>","text":"<p>Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert space dimension</p> required <code>k</code> <code>int</code> <p>fock number</p> required <p>Returns:</p> Type Description <p>Fock State |k&gt;</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def basis(N: int, k: int):\n    \"\"\"Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.\n\n    Args:\n        N: Hilbert space dimension\n        k: fock number\n\n    Returns:\n        Fock State |k&gt;\n    \"\"\"\n    return Qarray.create(one_hot(k, N).reshape(N, 1))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.basis_like","title":"<code>basis_like(A, ks)</code>","text":"<p>Creates a |k&gt; (i.e. fock state) ket with the same space dims as A.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Qarray</code> <p>state or operator.</p> required <code>k</code> <p>fock number.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Fock State |k&gt; with the same space dims as A.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def basis_like(A: Qarray, ks: List[int]) -&gt; Qarray:\n    \"\"\"Creates a |k&gt; (i.e. fock state) ket with the same space dims as A.\n\n    Args:\n        A: state or operator.\n        k: fock number.\n\n    Returns:\n        Fock State |k&gt; with the same space dims as A.\n    \"\"\"\n    space_dims = A.space_dims \n    assert len(space_dims) == len(ks), \"len(ks) must be equal to len(space_dims)\"\n\n    kets = []\n    for j, k in enumerate(ks):\n        kets.append(basis(space_dims[j], k))\n    return tensor(*kets)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.batch_dag_data","title":"<code>batch_dag_data(op)</code>","text":"<p>Conjugate transpose.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>Array</code> <p>operator</p> required <p>Returns:</p> Type Description <code>Array</code> <p>conjugate of op, and transposes last two axes</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def batch_dag_data(op: Array) -&gt; Array:\n    \"\"\"Conjugate transpose.\n\n    Args:\n        op: operator\n\n    Returns:\n        conjugate of op, and transposes last two axes\n    \"\"\"\n    return jnp.moveaxis(\n        jnp.conj(op), -1, -2\n    )  # transposes last two axes, good for batching\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.calc_expect","title":"<code>calc_expect(op, states)</code>","text":"<p>Calculate expectation value of an operator given a list of states.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>Qarray</code> <p>operator</p> required <code>states</code> <code>List[Qarray]</code> <p>list of states</p> required <p>Returns:</p> Type Description <code>Array</code> <p>list of expectation values</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def calc_expect(op: Qarray, states: List[Qarray]) -&gt; Array:\n    \"\"\"Calculate expectation value of an operator given a list of states.\n\n    Args:\n        op: operator\n        states: list of states\n\n    Returns:\n        list of expectation values\n    \"\"\"\n\n    op = op.data\n    is_dm = states[0].is_dm()\n    states = jqts2jnps(states)\n\n    def calc_expect_ket_single(state: Array):\n        return (jnp.conj(state).T @ op @ state)[0][0]\n\n    def calc_expect_dm_single(state: Array):\n        return jnp.trace(op @ state)\n\n    if is_dm:\n        return vmap(calc_expect_dm_single)(states)\n    else:\n        return vmap(calc_expect_ket_single)(states)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.coherent","title":"<code>coherent(N, \u03b1)</code>","text":"<p>Coherent state.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert Space Size.</p> required <code>\u03b1</code> <code>complex</code> <p>coherent state amplitude.</p> required Return <p>Coherent state |\u03b1\u27e9.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def coherent(N: int, \u03b1: complex) -&gt; Qarray:\n    \"\"\"Coherent state.\n\n    Args:\n        N: Hilbert Space Size.\n        \u03b1: coherent state amplitude.\n\n    Return:\n        Coherent state |\u03b1\u27e9.\n    \"\"\"\n    return displace(N, \u03b1) @ basis(N, 0)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.cosm","title":"<code>cosm(qarr)</code>","text":"<p>Matrix cosine wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix cosine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def cosm(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Matrix cosine wrapper.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        matrix cosine\n    \"\"\"\n    dims = qarr.dims\n    data = cosm_data(qarr.data)\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.cosm_data","title":"<code>cosm_data(data, **kwargs)</code>","text":"<p>Matrix cosine wrapper.</p> <p>Returns:</p> Type Description <code>Array</code> <p>matrix cosine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def cosm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix cosine wrapper.\n\n    Returns:\n        matrix cosine\n    \"\"\"\n    return (expm_data(1j*data) + expm_data(-1j*data))/2 \n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.create","title":"<code>create(N)</code>","text":"<p>creation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>creation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def create(N) -&gt; Qarray:\n    \"\"\"creation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        creation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=-1))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.dag","title":"<code>dag(qarr)</code>","text":"<p>Conjugate transpose.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>conjugate transpose of qarr</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def dag(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Conjugate transpose.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        conjugate transpose of qarr\n    \"\"\"\n    data = jnp.conj(qarr.data).T\n    dims = deepcopy(qarr.dims)\n    dims = dims[::-1]\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.dag_data","title":"<code>dag_data(op)</code>","text":"<p>Conjugate transpose.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>Array</code> <p>operator</p> required <p>Returns:</p> Type Description <code>Array</code> <p>conjugate of op, and transposes last two axes</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def dag_data(op: Array) -&gt; Array:\n    \"\"\"Conjugate transpose.\n\n    Args:\n        op: operator\n\n    Returns:\n        conjugate of op, and transposes last two axes\n    \"\"\"\n    return jnp.conj(op.T) \n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.destroy","title":"<code>destroy(N)</code>","text":"<p>annihilation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>annilation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def destroy(N) -&gt; Qarray:\n    \"\"\"annihilation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        annilation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=1))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.displace","title":"<code>displace(N, \u03b1)</code>","text":"<p>Displacement operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space Size</p> required <code>\u03b1</code> <p>Phase space displacement</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Displace operator D(\u03b1)</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def displace(N, \u03b1) -&gt; Qarray:\n    \"\"\"Displacement operator\n\n    Args:\n        N: Hilbert Space Size\n        \u03b1: Phase space displacement\n\n    Returns:\n        Displace operator D(\u03b1)\n    \"\"\"\n    a = destroy(N)\n    return (\u03b1 * a.dag() - jnp.conj(\u03b1) * a).expm()\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.eigenenergies","title":"<code>eigenenergies(qarr)</code>","text":"<p>Eigenvalues of a quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>eigenvalues</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def eigenenergies(qarr: Qarray) -&gt; Array:\n    \"\"\"Eigenvalues of a quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        eigenvalues\n    \"\"\"\n\n    evals = jnp.linalg.eigvalsh(qarr.data)\n    return evals\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.eigenstates","title":"<code>eigenstates(qarr)</code>","text":"<p>Eigenstates of a quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>eigenvalues and eigenstates</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def eigenstates(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Eigenstates of a quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        eigenvalues and eigenstates\n    \"\"\"\n\n    evals, evecs = jnp.linalg.eigh(qarr.data)\n    idxs_sorted = jnp.argsort(evals)\n\n    dims = ket_from_op_dims(qarr.dims)\n\n    evals =  evals[idxs_sorted]\n    evecs = evecs[:, idxs_sorted]\n    evecs = [Qarray.create(arr, dims=dims) for arr in evecs]\n\n    return evals, evecs\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.expm","title":"<code>expm(qarr, **kwargs)</code>","text":"<p>Matrix exponential wrapper.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix exponential</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def expm(qarr: Qarray, **kwargs) -&gt; Qarray:\n    \"\"\"Matrix exponential wrapper.\n\n    Returns:\n        matrix exponential\n    \"\"\"\n    dims = qarr.dims\n    data = expm_data(qarr.data, **kwargs)\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.expm_data","title":"<code>expm_data(data, **kwargs)</code>","text":"<p>Matrix exponential wrapper.</p> <p>Returns:</p> Type Description <code>Array</code> <p>matrix exponential</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def expm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix exponential wrapper.\n\n    Returns:\n        matrix exponential\n    \"\"\"\n    return jsp.linalg.expm(data, **kwargs)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.extract_dims","title":"<code>extract_dims(arr, dims=None)</code>","text":"<p>Extract dims from a JAX array or Qarray.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Array</code> <p>JAX array or Qarray.</p> required <code>dims</code> <code>Optional[Union[DIMS_TYPE, List[int]]]</code> <p>Qarray dims.</p> <code>None</code> <p>Returns:</p> Type Description <p>Qarray dims.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def extract_dims(arr: Array, dims: Optional[Union[DIMS_TYPE, List[int]]] = None):\n    \"\"\"Extract dims from a JAX array or Qarray.\n\n    Args:\n        arr: JAX array or Qarray.\n        dims: Qarray dims.\n\n    Returns:\n        Qarray dims.\n    \"\"\"\n    if isinstance(dims[0], Number):\n        is_op = len(arr.shape) == 2 and arr.shape[0] == arr.shape[1]\n        if is_op:\n            dims = [dims, dims]\n        else:\n            dims = [dims, [1] * len(dims)] # defaults to ket \n    return dims\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.hadamard","title":"<code>hadamard()</code>","text":"<p>H</p> <p>Returns:</p> Name Type Description <code>H</code> <code>Qarray</code> <p>Hadamard gate</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def hadamard() -&gt; Qarray:\n    \"\"\"H\n\n    Returns:\n        H: Hadamard gate\n    \"\"\"\n    return Qarray.create(jnp.array([[1, 1], [1, -1]]) / jnp.sqrt(2))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.identity","title":"<code>identity(*args, **kwargs)</code>","text":"<p>Identity matrix.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Identity matrix.\n\n    Returns:\n        Identity matrix.\n    \"\"\"\n    return Qarray.create(jnp.eye(*args, **kwargs))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.identity_like","title":"<code>identity_like(A)</code>","text":"<p>Identity matrix with the same shape as A.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <p>Matrix.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix with the same shape as A.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity_like(A) -&gt; Qarray:\n    \"\"\"Identity matrix with the same shape as A.\n\n    Args:\n        A: Matrix.\n\n    Returns:\n        Identity matrix with the same shape as A.\n    \"\"\"\n    space_dims = A.space_dims \n    total_dim = prod(space_dims)\n    return Qarray.create(jnp.eye(total_dim, total_dim), dims=[space_dims, space_dims])\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.jnp2jqt","title":"<code>jnp2jqt(arr, dims=None)</code>","text":"<p>JAX array -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jnp_obj</code> <p>JAX array.</p> required <code>dims</code> <code>Optional[Union[DIMS_TYPE, List[int]]]</code> <p>Qarray dims.</p> <code>None</code> <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jnp2jqt(arr: Array, dims: Optional[Union[DIMS_TYPE, List[int]]] = None):\n    \"\"\"JAX array -&gt; QuTiP state.\n\n    Args:\n        jnp_obj: JAX array.\n        dims: Qarray dims.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n    dims = extract_dims(arr, dims) if dims is not None else None\n    return Qarray.create(arr, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.jnps2jqts","title":"<code>jnps2jqts(arrs, dims=None)</code>","text":"<p>JAX array -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jnp_obj</code> <p>JAX array.</p> required <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jnps2jqts(arrs: Array, dims: Optional[DIMS_TYPE] = None):\n    \"\"\"JAX array -&gt; QuTiP state.\n\n    Args:\n        jnp_obj: JAX array.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n\n    dims = extract_dims(arrs[0], dims) if dims is not None else None\n    return [Qarray.create(arr, dims=dims) for arr in arrs]\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.jqt2qt","title":"<code>jqt2qt(jqt_obj)</code>","text":"<p>Qarray -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jqt_obj</code> <p>Qarray.</p> required <code>dims</code> <p>QuTiP dims.</p> required <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jqt2qt(jqt_obj):\n    \"\"\"Qarray -&gt; QuTiP state.\n\n    Args:\n        jqt_obj: Qarray.\n        dims: QuTiP dims.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n    if isinstance(jqt_obj, Qobj) or jqt_obj is None:\n        return jqt_obj\n\n    return Qobj(np.array(jqt_obj.data), dims=jqt_obj.dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.jqts2jnps","title":"<code>jqts2jnps(qarrs)</code>","text":"<p>QuTiP state -&gt; JAX array.</p> <p>Parameters:</p> Name Type Description Default <code>qt_obj</code> <p>QuTiP state.</p> required <p>Returns:</p> Type Description <p>JAX array.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jqts2jnps(qarrs: Qarray):\n    \"\"\"QuTiP state -&gt; JAX array.\n\n    Args:\n        qt_obj: QuTiP state.\n\n    Returns:\n        JAX array.\n    \"\"\"\n    return jnp.array([qarr.data for qarr in qarrs])\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.ket2dm","title":"<code>ket2dm(qarr)</code>","text":"<p>Turns ket into density matrix. Does nothing if already operator.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>qarr</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Density matrix</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def ket2dm(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Turns ket into density matrix.\n    Does nothing if already operator.\n\n    Args:\n        qarr (Qarray): qarr\n\n    Returns:\n        Density matrix\n    \"\"\"\n\n    if qarr.qtype == Qtypes.oper:\n        return qarr\n\n    if qarr.qtype == Qtypes.bra:\n        qarr = qarr.dag()\n\n    return qarr @ qarr.dag()\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.mesolve","title":"<code>mesolve(\u03c10, t_list, c_ops=None, H0=None, Ht=None, solver_options=None)</code>","text":"<p>Quantum Master Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>\u03c10</code> <code>Qarray</code> <p>initial state, must be a density matrix. For statevector evolution, please use sesolve.</p> required <code>t_list</code> <code>Array</code> <p>time list</p> required <code>c_ops</code> <code>Optional[List[Qarray]]</code> <p>list of collapse operators</p> <code>None</code> <code>H0</code> <code>Optional[Qarray]</code> <p>time independent Hamiltonian. If H0 is not None, it will override Ht.</p> <code>None</code> <code>Ht</code> <code>Optional[Callable[[float], Qarray]]</code> <p>time dependent Hamiltonian function.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def mesolve(\n    \u03c10: Qarray,\n    t_list: Array,\n    c_ops: Optional[List[Qarray]] = None,\n    H0: Optional[Qarray] = None,\n    Ht: Optional[Callable[[float], Qarray]] = None,\n    solver_options: Optional[SolverOptions] = None\n):\n    \"\"\"Quantum Master Equation solver.\n\n    Args:\n        \u03c10: initial state, must be a density matrix. For statevector evolution, please use sesolve.\n        t_list: time list\n        c_ops: list of collapse operators\n        H0: time independent Hamiltonian. If H0 is not None, it will override Ht.\n        Ht: time dependent Hamiltonian function.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    c_ops = c_ops or []\n\n    if len(c_ops) == 0 and \u03c10.qtype != Qtypes.oper:\n        logging.warning(\n            \"Consider using `jqt.sesolve()` instead, as `c_ops` is an empty list and the initial state is not a density matrix.\"\n        )\n\n    \u03c10 = \u03c10.to_dm()\n    dims = \u03c10.dims\n    \u03c10 = \u03c10.data\n\n    c_ops = [c_op.data for c_op in c_ops]\n    H0 = jnp.asarray(H0.data) if H0 is not None else None\n    Ht_data = lambda t: Ht(t).data if Ht is not None else None\n\n    ys = mesolve_data(\u03c10, t_list, c_ops, H0, Ht_data, solver_options)\n\n    return jnps2jqts(ys, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.mesolve_data","title":"<code>mesolve_data(\u03c10, t_list, c_ops=None, H0=None, Ht=None, solver_options=None)</code>","text":"<p>Quantum Master Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>\u03c10</code> <code>Array</code> <p>initial state, must be a density matrix. For statevector evolution, please use sesolve.</p> required <code>t_list</code> <code>Array</code> <p>time list</p> required <code>c_ops</code> <code>Optional[List[Array]]</code> <p>list of collapse operators</p> <code>None</code> <code>H0</code> <code>Optional[Array]</code> <p>time independent Hamiltonian. If H0 is not None, it will override Ht.</p> <code>None</code> <code>Ht</code> <code>Optional[Callable[[float], Array]]</code> <p>time dependent Hamiltonian function.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def mesolve_data(\n    \u03c10: Array,\n    t_list: Array,\n    c_ops: Optional[List[Array]] = None,\n    H0: Optional[Array] = None,\n    Ht: Optional[Callable[[float], Array]] = None,\n    solver_options: Optional[SolverOptions] = None\n):\n    \"\"\"Quantum Master Equation solver.\n\n    Args:\n        \u03c10: initial state, must be a density matrix. For statevector evolution, please use sesolve.\n        t_list: time list\n        c_ops: list of collapse operators\n        H0: time independent Hamiltonian. If H0 is not None, it will override Ht.\n        Ht: time dependent Hamiltonian function.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    c_ops = c_ops or []\n\n    if len(c_ops) == 0:\n        logging.warning(\n            \"Consider using `jqt.sesolve()` instead, as `c_ops` is an empty list and the initial state is not a density matrix.\"\n        )\n\n    \u03c10 = \u03c10 + 0.0j\n\n    c_ops = jnp.asarray([c_op for c_op in c_ops]) + 0.0j\n    H0 = H0 + 0.0j if H0 is not None else None\n\n    def f(\n        t: float,\n        rho: Array,\n        args: Array,\n    ):\n        H0_val = args[0]\n        c_ops_val = args[1]\n\n        if H0_val is not None:\n            H = H0_val  # use H0 if given\n        else:\n            H = Ht(t)  # type: ignore\n            H = H + 0.0j\n\n        rho_dot = -1j * (H @ rho - rho @ H)\n\n        for op in c_ops_val:\n            rho_dot += spre(op)(rho)\n\n        return rho_dot\n\n\n    sol = solve(\u03c10, f, t_list, [H0, c_ops], solver_options=solver_options)\n\n    return sol.ys\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.num","title":"<code>num(N)</code>","text":"<p>Number operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>number operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def num(N) -&gt; Qarray:\n    \"\"\"Number operator\n\n    Args:\n        N: Hilbert Space size\n\n    Returns:\n        number operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.arange(N)))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.op2jqts","title":"<code>op2jqts(op, cols=True)</code>","text":"<p>QuTiP operator -&gt; JAX array.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>Qarray</code> <p>QuTiP operator.</p> required <p>Returns:</p> Type Description <p>JAX array.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def op2jqts(op: Qarray, cols=True):\n    \"\"\"QuTiP operator -&gt; JAX array.\n\n    Args:\n        op: QuTiP operator.\n\n    Returns:\n        JAX array.\n    \"\"\"\n    if op.qtype != Qtypes.oper:\n        raise ValueError(\"Input must be a QuTiP operator.\")\n\n    space_dims = op.space_dims\n    ones = [1] * len(space_dims)\n\n    if cols:\n        return [Qarray.create(op.data[i,:], dims=[space_dims, ones]) for i in range(op.data.shape[0])]\n    else:\n        return [Qarray.create(op.data[:,i][jnp.newaxis,...], dims=[ones, space_dims]) for i in range(op.data.shape[1])]\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.plot_qp","title":"<code>plot_qp(state, pts, ax=None, contour=True, qp_type=WIGNER)</code>","text":"<p>Plot quasi-probability distribution.</p> <p>TODO: decouple this from qutip.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>statevector</p> required <code>pts</code> <p>points to evaluate quasi-probability distribution on</p> required <code>dim</code> <p>dimensions of state</p> required <code>ax</code> <p>matplotlib axis to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>qp_type</code> <p>type of quasi probability distribution (\"wigner\", \"qfunc\")</p> <code>WIGNER</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_qp(state, pts, ax=None, contour=True, qp_type=WIGNER):\n    \"\"\"Plot quasi-probability distribution.\n\n    TODO: decouple this from qutip.\n\n    Args:\n        state: statevector\n        pts: points to evaluate quasi-probability distribution on\n        dim: dimensions of state\n        ax: matplotlib axis to plot on\n        contour: make the plot use contouring\n        qp_type: type of quasi probability distribution (\"wigner\", \"qfunc\")\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    pts = np.array(pts)\n    state = jqt2qt(state)\n    if ax is None:\n        _, ax = plt.subplots(1, figsize=(4, 3), dpi=200)\n    # fig = ax.get_figure()\n\n    if qp_type == WIGNER:\n        vmin = -1\n        vmax = 1\n        scale = np.pi / 2\n        cmap = \"seismic\"\n    elif qp_type == QFUNC:\n        vmin = 0\n        vmax = 1\n        scale = np.pi\n        cmap = \"jet\"\n\n    QP = scale * getattr(qt, qp_type)(state, pts, pts, g=2)\n\n    if contour:\n        im = ax.contourf(\n            pts,\n            pts,\n            QP,\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            levels=np.linspace(vmin, vmax, 101),\n        )\n    else:\n        im = ax.pcolormesh(\n            pts,\n            pts,\n            QP,\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n        )\n    ax.axhline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n    ax.axvline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n    ax.grid()\n    ax.set_aspect(\"equal\", adjustable=\"box\")\n    return im\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.powm","title":"<code>powm(qarr, n)</code>","text":"<p>Matrix power.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <code>n</code> <code>int</code> <p>power</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix power</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def powm(qarr: Qarray, n: int) -&gt; Qarray:\n    \"\"\"Matrix power.\n\n    Args:\n        qarr (Qarray): quantum array\n        n (int): power\n\n    Returns:\n        matrix power\n    \"\"\"\n    data = jnp.linalg.matrix_power(qarr.data, n)\n    return Qarray.create(data, dims=qarr.dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.propagator","title":"<code>propagator(H, t, solver_options=None)</code>","text":"<p>Generate the propagator for a time dependent Hamiltonian. </p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Qarray or callable</code> <p>A Qarray static Hamiltonian OR a function that takes a time argument and returns a Hamiltonian. </p> required <code>ts</code> <code>float or Array</code> <p>A single time point or an Array of time points.</p> required <p>Returns:</p> Type Description <p>Qarray or List[Qarray]:  The propagator for the Hamiltonian at time t. OR a list of propagators for the Hamiltonian at each time in t.</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def propagator(\n    H: Union[Qarray, Callable[[float], Qarray]],\n    t: Union[float, Array],\n    solver_options=None\n):\n    \"\"\" Generate the propagator for a time dependent Hamiltonian. \n\n    Args:\n        H (Qarray or callable): \n            A Qarray static Hamiltonian OR\n            a function that takes a time argument and returns a Hamiltonian. \n        ts (float or Array): \n            A single time point or\n            an Array of time points.\n\n    Returns:\n        Qarray or List[Qarray]: \n            The propagator for the Hamiltonian at time t.\n            OR a list of propagators for the Hamiltonian at each time in t.\n\n    \"\"\"\n\n    t_is_scalar = robust_isscalar(t)\n\n    if isinstance(H, Qarray):\n        dims = H.dims \n        if t_is_scalar:\n            if t == 0:\n                return identity_like(H)\n\n            return jnp2jqt(propagator_0_data(H.data,t), dims=dims)\n        else:\n            f = lambda t: propagator_0_data(H.data,t)\n            return jnps2jqts(vmap(f)(t), dims)\n    else:\n        dims = H(0.0).dims\n        H_data = lambda t: H(t).data\n        if t_is_scalar:\n            if t == 0:\n                return identity_like(H(0.0))\n\n            ts = jnp.linspace(0,t,2)\n            return jnp2jqt(\n                propagator_t_data(H_data, ts, solver_options=solver_options)[1],\n                dims=dims\n            )\n        else:\n            ts = t \n            U_props = propagator_t_data(H_data, ts, solver_options=solver_options)\n            return jnps2jqts(U_props, dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.propagator_0_data","title":"<code>propagator_0_data(H0, t)</code>","text":"<p>Generate the propagator for a time independent Hamiltonian. </p> <p>Parameters:</p> Name Type Description Default <code>H0</code> <code>Qarray</code> <p>The Hamiltonian.</p> required <p>Returns:</p> Name Type Description <code>Qarray</code> <p>The propagator for the time independent Hamiltonian.</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def propagator_0_data(\n    H0: Array,\n    t: float\n):\n    \"\"\" Generate the propagator for a time independent Hamiltonian. \n\n    Args:\n        H0 (Qarray): The Hamiltonian.\n\n    Returns:\n        Qarray: The propagator for the time independent Hamiltonian.\n    \"\"\"\n    return jsp.linalg.expm(-1j * H0 * t)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.propagator_t_data","title":"<code>propagator_t_data(Ht, ts, solver_options=None)</code>","text":"<p>Generate the propagator for a time dependent Hamiltonian. </p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>float</code> <p>The final time of the propagator.  Warning: Do not send in t. In this case, just do exp(-1j*Ht(0.0)).</p> required <code>Ht</code> <code>callable</code> <p>A function that takes a time argument and returns a Hamiltonian. </p> required <code>solver_options</code> <code>dict</code> <p>Options to pass to the solver.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Qarray</code> <p>The propagator for the time dependent Hamiltonian for the time range [0, t_final].</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def propagator_t_data(\n    Ht: Callable[[float], Array],\n    ts: Array, \n    solver_options=None\n):\n    \"\"\" Generate the propagator for a time dependent Hamiltonian. \n\n    Args:\n        ts (float): The final time of the propagator. \n            Warning: Do not send in t. In this case, just do exp(-1j*Ht(0.0)).\n        Ht (callable): A function that takes a time argument and returns a Hamiltonian. \n        solver_options (dict): Options to pass to the solver.\n\n    Returns:\n        Qarray: The propagator for the time dependent Hamiltonian for the time range [0, t_final].\n    \"\"\"\n    N = Ht(0).shape[0]\n    basis_states = jnp.eye(N)\n\n    def propogate_state(initial_state):\n        return sesolve_data(initial_state, ts, Ht=Ht, solver_options=solver_options)\n\n    U_prop = vmap(propogate_state)(basis_states)\n    U_prop = U_prop.transpose(1,0,2) # move time axis to the front\n    return U_prop\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.ptrace","title":"<code>ptrace(qarr, indx)</code>","text":"<p>Partial Trace.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <p>density matrix</p> required <code>indx</code> <p>index of quantum object to keep, rest will be partial traced out</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>partial traced out density matrix</p> <p>TODO: Fix weird tracing errors that arise with reshape</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def ptrace(qarr: Qarray, indx) -&gt; Qarray:\n    \"\"\"Partial Trace.\n\n    Args:\n        rho: density matrix\n        indx: index of quantum object to keep, rest will be partial traced out\n\n    Returns:\n        partial traced out density matrix\n\n    TODO: Fix weird tracing errors that arise with reshape\n    \"\"\"\n\n    qarr = ket2dm(qarr)\n    rho = qarr.shaped_data\n    dims = qarr.dims\n\n    Nq = len(dims[0])\n\n    indxs = [indx, indx + Nq]\n    for j in range(Nq):\n        if j == indx:\n            continue\n        indxs.append(j)\n        indxs.append(j + Nq)\n    rho = rho.transpose(indxs)\n\n    for j in range(Nq - 1):\n        rho = jnp.trace(rho, axis1=2, axis2=3)\n\n    return Qarray.create(rho)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.qt2jqt","title":"<code>qt2jqt(qt_obj, dtype=jnp.complex128)</code>","text":"<p>QuTiP state -&gt; Qarray.</p> <p>Parameters:</p> Name Type Description Default <code>qt_obj</code> <p>QuTiP state.</p> required <code>dtype</code> <p>JAX dtype.</p> <code>complex128</code> <p>Returns:</p> Type Description <p>Qarray.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def qt2jqt(qt_obj, dtype=jnp.complex128):\n    \"\"\"QuTiP state -&gt; Qarray.\n\n    Args:\n        qt_obj: QuTiP state.\n        dtype: JAX dtype.\n\n    Returns:\n        Qarray.\n    \"\"\"\n    if isinstance(qt_obj, Qarray) or qt_obj is None:\n        return qt_obj\n    return Qarray.create(jnp.array(qt_obj, dtype=dtype), dims=qt_obj.dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.sesolve","title":"<code>sesolve(\u03c8, t_list, H0=None, Ht=None, solver_options=None)</code>","text":"<p>Schr\u00f6dinger Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>\u03c8</code> <code>Qarray</code> <p>initial statevector</p> required <code>t_list</code> <code>Array</code> <p>time list</p> required <code>H0</code> <code>Optional[Qarray]</code> <p>time independent Hamiltonian. If H0 is not None, it will override Ht.</p> <code>None</code> <code>Ht</code> <code>Optional[Callable[[float], Qarray]]</code> <p>time dependent Hamiltonian function.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def sesolve(\n    \u03c8: Qarray,\n    t_list: Array,\n    H0: Optional[Qarray] = None,\n    Ht: Optional[Callable[[float], Qarray]] = None,\n    solver_options: Optional[SolverOptions] = None,\n):\n    \"\"\"Schr\u00f6dinger Equation solver.\n\n    Args:\n        \u03c8: initial statevector\n        t_list: time list\n        H0: time independent Hamiltonian. If H0 is not None, it will override Ht.\n        Ht: time dependent Hamiltonian function.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    if \u03c8.qtype == Qtypes.oper:\n        raise ValueError(\n            \"Please use `jqt.mesolve` for initial state inputs in density matrix form.\"\n        )\n\n    \u03c8 = \u03c8.to_ket()\n\n    dims = \u03c8.dims\n\n    \u03c8 = \u03c8.data \n    H0 = H0.data if H0 is not None else None\n    Ht_data = lambda t: Ht(t).data if Ht is not None else None\n\n    ys = sesolve_data(\u03c8, t_list, H0, Ht_data, solver_options)\n\n    return jnps2jqts(ys, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.sesolve_data","title":"<code>sesolve_data(\u03c8, t_list, H0=None, Ht=None, solver_options=None)</code>","text":"<p>Schr\u00f6dinger Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>\u03c8</code> <code>Array</code> <p>initial statevector</p> required <code>t_list</code> <code>Array</code> <p>time list</p> required <code>H0</code> <code>Optional[Array]</code> <p>time independent Hamiltonian. If H0 is not None, it will override Ht.</p> <code>None</code> <code>Ht</code> <code>Optional[Callable[[float], Array]]</code> <p>time dependent Hamiltonian function.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def sesolve_data(\n    \u03c8: Array,\n    t_list: Array,\n    H0: Optional[Array] = None,\n    Ht: Optional[Callable[[float], Array]] = None,\n    solver_options: Optional[SolverOptions] = None,\n):\n    \"\"\"Schr\u00f6dinger Equation solver.\n\n    Args:\n        \u03c8: initial statevector\n        t_list: time list\n        H0: time independent Hamiltonian. If H0 is not None, it will override Ht.\n        Ht: time dependent Hamiltonian function.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    \u03c8 = \u03c8 + 0.0j\n    H0 = H0 + 0.0j if H0 is not None else None\n    solver_options = solver_options or {}\n\n    def f(\n        t: float,\n        \u03c8\u209c: Array,\n        args: Array,\n    ):\n        H0_val = args[0]\n\n        if H0_val is not None:\n            H = H0_val  # use H0 if given\n        else:\n            H = Ht(t)  # type: ignore\n        # print(\"H\", H.shape)\n        # print(\"psit\", \u03c8\u209c.shape)\n        \u03c8\u209c_dot = -1j * (H @ \u03c8\u209c)\n\n        return \u03c8\u209c_dot\n\n\n    sol = solve(\u03c8, f, t_list, [H0], solver_options=solver_options)\n    return sol.ys\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.sigmam","title":"<code>sigmam()</code>","text":"<p>\u03c3-</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3- Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmam() -&gt; Qarray:\n    \"\"\"\u03c3-\n\n    Returns:\n        \u03c3- Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 0.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.sigmap","title":"<code>sigmap()</code>","text":"<p>\u03c3+</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3+ Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmap() -&gt; Qarray:\n    \"\"\"\u03c3+\n\n    Returns:\n        \u03c3+ Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [0.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.sigmax","title":"<code>sigmax()</code>","text":"<p>\u03c3x</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3x Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmax() -&gt; Qarray:\n    \"\"\"\u03c3x\n\n    Returns:\n        \u03c3x Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.sigmay","title":"<code>sigmay()</code>","text":"<p>\u03c3y</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3y Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmay() -&gt; Qarray:\n    \"\"\"\u03c3y\n\n    Returns:\n        \u03c3y Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, -1.0j], [1.0j, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.sigmaz","title":"<code>sigmaz()</code>","text":"<p>\u03c3z</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3z Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmaz() -&gt; Qarray:\n    \"\"\"\u03c3z\n\n    Returns:\n        \u03c3z Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[1.0, 0.0], [0.0, -1.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.sinm_data","title":"<code>sinm_data(data, **kwargs)</code>","text":"<p>Matrix sine wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>matrix</p> required <p>Returns:</p> Type Description <code>Array</code> <p>matrix sine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def sinm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix sine wrapper.\n\n    Args:\n        data: matrix\n\n    Returns:\n        matrix sine\n    \"\"\"\n    return (expm_data(1j*data) - expm_data(-1j*data))/(2j)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.solve","title":"<code>solve(\u03c10, f, t_list, args, solver_options=None)</code>","text":"<p>Gets teh desired solver from diffrax.</p> <p>Parameters:</p> Name Type Description Default <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>dictionary with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>solution</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def solve(\u03c10, f, t_list, args, solver_options: Optional[SolverOptions] = None):\n    \"\"\" Gets teh desired solver from diffrax.\n\n    Args:\n        solver_options: dictionary with solver options\n\n    Returns:\n        solution \n    \"\"\"\n\n    # f and ts\n    term = ODETerm(f)\n    saveat = SaveAt(ts=t_list)\n\n    # solver \n    solver_options = solver_options or SolverOptions.create()\n\n    solver_name = solver_options.solver\n    solver = getattr(diffrax, solver_name)()\n    stepsize_controller = PIDController(rtol=1e-6, atol=1e-6)\n\n    # solve!\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', UserWarning) # NOTE: suppresses complex dtype warning in diffrax\n        sol = diffeqsolve(\n            term,\n            solver,\n            t0=t_list[0],\n            t1=t_list[-1],\n            dt0=t_list[1] - t_list[0],\n            y0=\u03c10,\n            saveat=saveat,\n            stepsize_controller=stepsize_controller,\n            args=args,\n            max_steps=solver_options.max_steps,\n            progress_meter=CustomProgressMeter() if solver_options.progress_meter else NoProgressMeter(),\n        )   \n\n    return sol\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.spre","title":"<code>spre(op)</code>","text":"<p>Superoperator generator.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>Array</code> <p>operator to be turned into a superoperator</p> required <p>Returns:</p> Type Description <code>Callable[[Array], Array]</code> <p>superoperator function</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def spre(op: Array) -&gt; Callable[[Array], Array]:\n    \"\"\"Superoperator generator.\n\n    Args:\n        op: operator to be turned into a superoperator\n\n    Returns:\n        superoperator function\n    \"\"\"\n    op_dag = op.conj().T\n    return lambda rho: 0.5 * (\n        2 * op @ rho @ op_dag - rho @ op_dag @ op - op_dag @ op @ rho\n    )\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.tensor","title":"<code>tensor(*args, **kwargs)</code>","text":"<p>Tensor product.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Qarray</code> <p>tensors to take the product of</p> <code>()</code> <p>Returns:</p> Type Description <code>Qarray</code> <p>Tensor product of given tensors</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tensor(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Tensor product.\n\n    Args:\n        *args (Qarray): tensors to take the product of\n\n    Returns:\n        Tensor product of given tensors\n\n    \"\"\"\n    data = args[0].data\n    dims = deepcopy(args[0].dims)\n    for arg in args[1:]:\n        data = jnp.kron(data, arg.data)\n        dims[0] += arg.dims[0]\n        dims[1] += arg.dims[1]\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.tr","title":"<code>tr(qarr, **kwargs)</code>","text":"<p>Full trace.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array    </p> required <p>Returns:</p> Type Description <code>complex128</code> <p>Full trace.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tr(qarr: Qarray, **kwargs) -&gt; jnp.complex128:\n    \"\"\"Full trace.\n\n    Args:\n        qarr (Qarray): quantum array    \n\n    Returns:\n        Full trace.\n    \"\"\"\n    return trace(qarr, **kwargs)\n</code></pre>"},{"location":"reference/jaxquantum/core/index.html#jaxquantum.core.unit","title":"<code>unit(qarr)</code>","text":"<p>Normalize the quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Normalized quantum array</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def unit(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Normalize the quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        Normalized quantum array\n    \"\"\"\n    data = qarr.data\n\n    if qarr.qtype == Qtypes.oper:\n        evals, _ = jnp.linalg.eigh(data @ jnp.conj(data).T)\n        rho_norm = jnp.sum(jnp.sqrt(jnp.abs(evals)))\n        data = data / rho_norm\n    elif qarr.qtype in [Qtypes.ket, Qtypes.bra]:\n        data = data / jnp.linalg.norm(data)\n\n    return Qarray.create(data, dims=qarr.dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/conversions.html","title":"conversions","text":"<p>Converting between different object types.</p>"},{"location":"reference/jaxquantum/core/conversions.html#jaxquantum.core.conversions.extract_dims","title":"<code>extract_dims(arr, dims=None)</code>","text":"<p>Extract dims from a JAX array or Qarray.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Array</code> <p>JAX array or Qarray.</p> required <code>dims</code> <code>Optional[Union[DIMS_TYPE, List[int]]]</code> <p>Qarray dims.</p> <code>None</code> <p>Returns:</p> Type Description <p>Qarray dims.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def extract_dims(arr: Array, dims: Optional[Union[DIMS_TYPE, List[int]]] = None):\n    \"\"\"Extract dims from a JAX array or Qarray.\n\n    Args:\n        arr: JAX array or Qarray.\n        dims: Qarray dims.\n\n    Returns:\n        Qarray dims.\n    \"\"\"\n    if isinstance(dims[0], Number):\n        is_op = len(arr.shape) == 2 and arr.shape[0] == arr.shape[1]\n        if is_op:\n            dims = [dims, dims]\n        else:\n            dims = [dims, [1] * len(dims)] # defaults to ket \n    return dims\n</code></pre>"},{"location":"reference/jaxquantum/core/conversions.html#jaxquantum.core.conversions.jnp2jqt","title":"<code>jnp2jqt(arr, dims=None)</code>","text":"<p>JAX array -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jnp_obj</code> <p>JAX array.</p> required <code>dims</code> <code>Optional[Union[DIMS_TYPE, List[int]]]</code> <p>Qarray dims.</p> <code>None</code> <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jnp2jqt(arr: Array, dims: Optional[Union[DIMS_TYPE, List[int]]] = None):\n    \"\"\"JAX array -&gt; QuTiP state.\n\n    Args:\n        jnp_obj: JAX array.\n        dims: Qarray dims.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n    dims = extract_dims(arr, dims) if dims is not None else None\n    return Qarray.create(arr, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/conversions.html#jaxquantum.core.conversions.jnps2jqts","title":"<code>jnps2jqts(arrs, dims=None)</code>","text":"<p>JAX array -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jnp_obj</code> <p>JAX array.</p> required <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jnps2jqts(arrs: Array, dims: Optional[DIMS_TYPE] = None):\n    \"\"\"JAX array -&gt; QuTiP state.\n\n    Args:\n        jnp_obj: JAX array.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n\n    dims = extract_dims(arrs[0], dims) if dims is not None else None\n    return [Qarray.create(arr, dims=dims) for arr in arrs]\n</code></pre>"},{"location":"reference/jaxquantum/core/conversions.html#jaxquantum.core.conversions.jqt2qt","title":"<code>jqt2qt(jqt_obj)</code>","text":"<p>Qarray -&gt; QuTiP state.</p> <p>Parameters:</p> Name Type Description Default <code>jqt_obj</code> <p>Qarray.</p> required <code>dims</code> <p>QuTiP dims.</p> required <p>Returns:</p> Type Description <p>QuTiP state.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jqt2qt(jqt_obj):\n    \"\"\"Qarray -&gt; QuTiP state.\n\n    Args:\n        jqt_obj: Qarray.\n        dims: QuTiP dims.\n\n    Returns:\n        QuTiP state.\n    \"\"\"\n    if isinstance(jqt_obj, Qobj) or jqt_obj is None:\n        return jqt_obj\n\n    return Qobj(np.array(jqt_obj.data), dims=jqt_obj.dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/conversions.html#jaxquantum.core.conversions.jqts2jnps","title":"<code>jqts2jnps(qarrs)</code>","text":"<p>QuTiP state -&gt; JAX array.</p> <p>Parameters:</p> Name Type Description Default <code>qt_obj</code> <p>QuTiP state.</p> required <p>Returns:</p> Type Description <p>JAX array.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def jqts2jnps(qarrs: Qarray):\n    \"\"\"QuTiP state -&gt; JAX array.\n\n    Args:\n        qt_obj: QuTiP state.\n\n    Returns:\n        JAX array.\n    \"\"\"\n    return jnp.array([qarr.data for qarr in qarrs])\n</code></pre>"},{"location":"reference/jaxquantum/core/conversions.html#jaxquantum.core.conversions.op2jqts","title":"<code>op2jqts(op, cols=True)</code>","text":"<p>QuTiP operator -&gt; JAX array.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>Qarray</code> <p>QuTiP operator.</p> required <p>Returns:</p> Type Description <p>JAX array.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def op2jqts(op: Qarray, cols=True):\n    \"\"\"QuTiP operator -&gt; JAX array.\n\n    Args:\n        op: QuTiP operator.\n\n    Returns:\n        JAX array.\n    \"\"\"\n    if op.qtype != Qtypes.oper:\n        raise ValueError(\"Input must be a QuTiP operator.\")\n\n    space_dims = op.space_dims\n    ones = [1] * len(space_dims)\n\n    if cols:\n        return [Qarray.create(op.data[i,:], dims=[space_dims, ones]) for i in range(op.data.shape[0])]\n    else:\n        return [Qarray.create(op.data[:,i][jnp.newaxis,...], dims=[ones, space_dims]) for i in range(op.data.shape[1])]\n</code></pre>"},{"location":"reference/jaxquantum/core/conversions.html#jaxquantum.core.conversions.qt2jqt","title":"<code>qt2jqt(qt_obj, dtype=jnp.complex128)</code>","text":"<p>QuTiP state -&gt; Qarray.</p> <p>Parameters:</p> Name Type Description Default <code>qt_obj</code> <p>QuTiP state.</p> required <code>dtype</code> <p>JAX dtype.</p> <code>complex128</code> <p>Returns:</p> Type Description <p>Qarray.</p> Source code in <code>jaxquantum/core/conversions.py</code> <pre><code>def qt2jqt(qt_obj, dtype=jnp.complex128):\n    \"\"\"QuTiP state -&gt; Qarray.\n\n    Args:\n        qt_obj: QuTiP state.\n        dtype: JAX dtype.\n\n    Returns:\n        Qarray.\n    \"\"\"\n    if isinstance(qt_obj, Qarray) or qt_obj is None:\n        return qt_obj\n    return Qarray.create(jnp.array(qt_obj, dtype=dtype), dims=qt_obj.dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html","title":"operators","text":"<p>States.</p>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.basis","title":"<code>basis(N, k)</code>","text":"<p>Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert space dimension</p> required <code>k</code> <code>int</code> <p>fock number</p> required <p>Returns:</p> Type Description <p>Fock State |k&gt;</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def basis(N: int, k: int):\n    \"\"\"Creates a |k&gt; (i.e. fock state) ket in a specified Hilbert Space.\n\n    Args:\n        N: Hilbert space dimension\n        k: fock number\n\n    Returns:\n        Fock State |k&gt;\n    \"\"\"\n    return Qarray.create(one_hot(k, N).reshape(N, 1))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.basis_like","title":"<code>basis_like(A, ks)</code>","text":"<p>Creates a |k&gt; (i.e. fock state) ket with the same space dims as A.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Qarray</code> <p>state or operator.</p> required <code>k</code> <p>fock number.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Fock State |k&gt; with the same space dims as A.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def basis_like(A: Qarray, ks: List[int]) -&gt; Qarray:\n    \"\"\"Creates a |k&gt; (i.e. fock state) ket with the same space dims as A.\n\n    Args:\n        A: state or operator.\n        k: fock number.\n\n    Returns:\n        Fock State |k&gt; with the same space dims as A.\n    \"\"\"\n    space_dims = A.space_dims \n    assert len(space_dims) == len(ks), \"len(ks) must be equal to len(space_dims)\"\n\n    kets = []\n    for j, k in enumerate(ks):\n        kets.append(basis(space_dims[j], k))\n    return tensor(*kets)\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.coherent","title":"<code>coherent(N, \u03b1)</code>","text":"<p>Coherent state.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>Hilbert Space Size.</p> required <code>\u03b1</code> <code>complex</code> <p>coherent state amplitude.</p> required Return <p>Coherent state |\u03b1\u27e9.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def coherent(N: int, \u03b1: complex) -&gt; Qarray:\n    \"\"\"Coherent state.\n\n    Args:\n        N: Hilbert Space Size.\n        \u03b1: coherent state amplitude.\n\n    Return:\n        Coherent state |\u03b1\u27e9.\n    \"\"\"\n    return displace(N, \u03b1) @ basis(N, 0)\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.create","title":"<code>create(N)</code>","text":"<p>creation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>creation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def create(N) -&gt; Qarray:\n    \"\"\"creation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        creation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=-1))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.destroy","title":"<code>destroy(N)</code>","text":"<p>annihilation operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>annilation operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def destroy(N) -&gt; Qarray:\n    \"\"\"annihilation operator\n\n    Args:\n        N: Hilbert space size\n\n    Returns:\n        annilation operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.sqrt(jnp.arange(1, N)), k=1))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.displace","title":"<code>displace(N, \u03b1)</code>","text":"<p>Displacement operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space Size</p> required <code>\u03b1</code> <p>Phase space displacement</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Displace operator D(\u03b1)</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def displace(N, \u03b1) -&gt; Qarray:\n    \"\"\"Displacement operator\n\n    Args:\n        N: Hilbert Space Size\n        \u03b1: Phase space displacement\n\n    Returns:\n        Displace operator D(\u03b1)\n    \"\"\"\n    a = destroy(N)\n    return (\u03b1 * a.dag() - jnp.conj(\u03b1) * a).expm()\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.hadamard","title":"<code>hadamard()</code>","text":"<p>H</p> <p>Returns:</p> Name Type Description <code>H</code> <code>Qarray</code> <p>Hadamard gate</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def hadamard() -&gt; Qarray:\n    \"\"\"H\n\n    Returns:\n        H: Hadamard gate\n    \"\"\"\n    return Qarray.create(jnp.array([[1, 1], [1, -1]]) / jnp.sqrt(2))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.identity","title":"<code>identity(*args, **kwargs)</code>","text":"<p>Identity matrix.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Identity matrix.\n\n    Returns:\n        Identity matrix.\n    \"\"\"\n    return Qarray.create(jnp.eye(*args, **kwargs))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.identity_like","title":"<code>identity_like(A)</code>","text":"<p>Identity matrix with the same shape as A.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <p>Matrix.</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Identity matrix with the same shape as A.</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def identity_like(A) -&gt; Qarray:\n    \"\"\"Identity matrix with the same shape as A.\n\n    Args:\n        A: Matrix.\n\n    Returns:\n        Identity matrix with the same shape as A.\n    \"\"\"\n    space_dims = A.space_dims \n    total_dim = prod(space_dims)\n    return Qarray.create(jnp.eye(total_dim, total_dim), dims=[space_dims, space_dims])\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.num","title":"<code>num(N)</code>","text":"<p>Number operator</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>Hilbert Space size</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>number operator in Hilber Space of size N</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def num(N) -&gt; Qarray:\n    \"\"\"Number operator\n\n    Args:\n        N: Hilbert Space size\n\n    Returns:\n        number operator in Hilber Space of size N\n    \"\"\"\n    return Qarray.create(jnp.diag(jnp.arange(N)))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.sigmam","title":"<code>sigmam()</code>","text":"<p>\u03c3-</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3- Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmam() -&gt; Qarray:\n    \"\"\"\u03c3-\n\n    Returns:\n        \u03c3- Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 0.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.sigmap","title":"<code>sigmap()</code>","text":"<p>\u03c3+</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3+ Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmap() -&gt; Qarray:\n    \"\"\"\u03c3+\n\n    Returns:\n        \u03c3+ Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [0.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.sigmax","title":"<code>sigmax()</code>","text":"<p>\u03c3x</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3x Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmax() -&gt; Qarray:\n    \"\"\"\u03c3x\n\n    Returns:\n        \u03c3x Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, 1.0], [1.0, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.sigmay","title":"<code>sigmay()</code>","text":"<p>\u03c3y</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3y Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmay() -&gt; Qarray:\n    \"\"\"\u03c3y\n\n    Returns:\n        \u03c3y Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[0.0, -1.0j], [1.0j, 0.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/operators.html#jaxquantum.core.operators.sigmaz","title":"<code>sigmaz()</code>","text":"<p>\u03c3z</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>\u03c3z Pauli Operator</p> Source code in <code>jaxquantum/core/operators.py</code> <pre><code>def sigmaz() -&gt; Qarray:\n    \"\"\"\u03c3z\n\n    Returns:\n        \u03c3z Pauli Operator\n    \"\"\"\n    return Qarray.create(jnp.array([[1.0, 0.0], [0.0, -1.0]]))\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html","title":"qarray","text":"<p>QArray.</p>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.batch_dag_data","title":"<code>batch_dag_data(op)</code>","text":"<p>Conjugate transpose.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>Array</code> <p>operator</p> required <p>Returns:</p> Type Description <code>Array</code> <p>conjugate of op, and transposes last two axes</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def batch_dag_data(op: Array) -&gt; Array:\n    \"\"\"Conjugate transpose.\n\n    Args:\n        op: operator\n\n    Returns:\n        conjugate of op, and transposes last two axes\n    \"\"\"\n    return jnp.moveaxis(\n        jnp.conj(op), -1, -2\n    )  # transposes last two axes, good for batching\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.cosm","title":"<code>cosm(qarr)</code>","text":"<p>Matrix cosine wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix cosine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def cosm(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Matrix cosine wrapper.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        matrix cosine\n    \"\"\"\n    dims = qarr.dims\n    data = cosm_data(qarr.data)\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.cosm_data","title":"<code>cosm_data(data, **kwargs)</code>","text":"<p>Matrix cosine wrapper.</p> <p>Returns:</p> Type Description <code>Array</code> <p>matrix cosine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def cosm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix cosine wrapper.\n\n    Returns:\n        matrix cosine\n    \"\"\"\n    return (expm_data(1j*data) + expm_data(-1j*data))/2 \n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.dag","title":"<code>dag(qarr)</code>","text":"<p>Conjugate transpose.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>conjugate transpose of qarr</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def dag(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Conjugate transpose.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        conjugate transpose of qarr\n    \"\"\"\n    data = jnp.conj(qarr.data).T\n    dims = deepcopy(qarr.dims)\n    dims = dims[::-1]\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.dag_data","title":"<code>dag_data(op)</code>","text":"<p>Conjugate transpose.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>Array</code> <p>operator</p> required <p>Returns:</p> Type Description <code>Array</code> <p>conjugate of op, and transposes last two axes</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def dag_data(op: Array) -&gt; Array:\n    \"\"\"Conjugate transpose.\n\n    Args:\n        op: operator\n\n    Returns:\n        conjugate of op, and transposes last two axes\n    \"\"\"\n    return jnp.conj(op.T) \n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.eigenenergies","title":"<code>eigenenergies(qarr)</code>","text":"<p>Eigenvalues of a quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>eigenvalues</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def eigenenergies(qarr: Qarray) -&gt; Array:\n    \"\"\"Eigenvalues of a quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        eigenvalues\n    \"\"\"\n\n    evals = jnp.linalg.eigvalsh(qarr.data)\n    return evals\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.eigenstates","title":"<code>eigenstates(qarr)</code>","text":"<p>Eigenstates of a quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>eigenvalues and eigenstates</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def eigenstates(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Eigenstates of a quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        eigenvalues and eigenstates\n    \"\"\"\n\n    evals, evecs = jnp.linalg.eigh(qarr.data)\n    idxs_sorted = jnp.argsort(evals)\n\n    dims = ket_from_op_dims(qarr.dims)\n\n    evals =  evals[idxs_sorted]\n    evecs = evecs[:, idxs_sorted]\n    evecs = [Qarray.create(arr, dims=dims) for arr in evecs]\n\n    return evals, evecs\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.expm","title":"<code>expm(qarr, **kwargs)</code>","text":"<p>Matrix exponential wrapper.</p> <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix exponential</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def expm(qarr: Qarray, **kwargs) -&gt; Qarray:\n    \"\"\"Matrix exponential wrapper.\n\n    Returns:\n        matrix exponential\n    \"\"\"\n    dims = qarr.dims\n    data = expm_data(qarr.data, **kwargs)\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.expm_data","title":"<code>expm_data(data, **kwargs)</code>","text":"<p>Matrix exponential wrapper.</p> <p>Returns:</p> Type Description <code>Array</code> <p>matrix exponential</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def expm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix exponential wrapper.\n\n    Returns:\n        matrix exponential\n    \"\"\"\n    return jsp.linalg.expm(data, **kwargs)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.ket2dm","title":"<code>ket2dm(qarr)</code>","text":"<p>Turns ket into density matrix. Does nothing if already operator.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>qarr</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Density matrix</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def ket2dm(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Turns ket into density matrix.\n    Does nothing if already operator.\n\n    Args:\n        qarr (Qarray): qarr\n\n    Returns:\n        Density matrix\n    \"\"\"\n\n    if qarr.qtype == Qtypes.oper:\n        return qarr\n\n    if qarr.qtype == Qtypes.bra:\n        qarr = qarr.dag()\n\n    return qarr @ qarr.dag()\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.powm","title":"<code>powm(qarr, n)</code>","text":"<p>Matrix power.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <code>n</code> <code>int</code> <p>power</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>matrix power</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def powm(qarr: Qarray, n: int) -&gt; Qarray:\n    \"\"\"Matrix power.\n\n    Args:\n        qarr (Qarray): quantum array\n        n (int): power\n\n    Returns:\n        matrix power\n    \"\"\"\n    data = jnp.linalg.matrix_power(qarr.data, n)\n    return Qarray.create(data, dims=qarr.dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.ptrace","title":"<code>ptrace(qarr, indx)</code>","text":"<p>Partial Trace.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <p>density matrix</p> required <code>indx</code> <p>index of quantum object to keep, rest will be partial traced out</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>partial traced out density matrix</p> <p>TODO: Fix weird tracing errors that arise with reshape</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def ptrace(qarr: Qarray, indx) -&gt; Qarray:\n    \"\"\"Partial Trace.\n\n    Args:\n        rho: density matrix\n        indx: index of quantum object to keep, rest will be partial traced out\n\n    Returns:\n        partial traced out density matrix\n\n    TODO: Fix weird tracing errors that arise with reshape\n    \"\"\"\n\n    qarr = ket2dm(qarr)\n    rho = qarr.shaped_data\n    dims = qarr.dims\n\n    Nq = len(dims[0])\n\n    indxs = [indx, indx + Nq]\n    for j in range(Nq):\n        if j == indx:\n            continue\n        indxs.append(j)\n        indxs.append(j + Nq)\n    rho = rho.transpose(indxs)\n\n    for j in range(Nq - 1):\n        rho = jnp.trace(rho, axis1=2, axis2=3)\n\n    return Qarray.create(rho)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.sinm_data","title":"<code>sinm_data(data, **kwargs)</code>","text":"<p>Matrix sine wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>matrix</p> required <p>Returns:</p> Type Description <code>Array</code> <p>matrix sine</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def sinm_data(data: Array, **kwargs) -&gt; Array:\n    \"\"\"Matrix sine wrapper.\n\n    Args:\n        data: matrix\n\n    Returns:\n        matrix sine\n    \"\"\"\n    return (expm_data(1j*data) - expm_data(-1j*data))/(2j)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.tensor","title":"<code>tensor(*args, **kwargs)</code>","text":"<p>Tensor product.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Qarray</code> <p>tensors to take the product of</p> <code>()</code> <p>Returns:</p> Type Description <code>Qarray</code> <p>Tensor product of given tensors</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tensor(*args, **kwargs) -&gt; Qarray:\n    \"\"\"Tensor product.\n\n    Args:\n        *args (Qarray): tensors to take the product of\n\n    Returns:\n        Tensor product of given tensors\n\n    \"\"\"\n    data = args[0].data\n    dims = deepcopy(args[0].dims)\n    for arg in args[1:]:\n        data = jnp.kron(data, arg.data)\n        dims[0] += arg.dims[0]\n        dims[1] += arg.dims[1]\n    return Qarray.create(data, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.tr","title":"<code>tr(qarr, **kwargs)</code>","text":"<p>Full trace.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array    </p> required <p>Returns:</p> Type Description <code>complex128</code> <p>Full trace.</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def tr(qarr: Qarray, **kwargs) -&gt; jnp.complex128:\n    \"\"\"Full trace.\n\n    Args:\n        qarr (Qarray): quantum array    \n\n    Returns:\n        Full trace.\n    \"\"\"\n    return trace(qarr, **kwargs)\n</code></pre>"},{"location":"reference/jaxquantum/core/qarray.html#jaxquantum.core.qarray.unit","title":"<code>unit(qarr)</code>","text":"<p>Normalize the quantum array.</p> <p>Parameters:</p> Name Type Description Default <code>qarr</code> <code>Qarray</code> <p>quantum array</p> required <p>Returns:</p> Type Description <code>Qarray</code> <p>Normalized quantum array</p> Source code in <code>jaxquantum/core/qarray.py</code> <pre><code>def unit(qarr: Qarray) -&gt; Qarray:\n    \"\"\"Normalize the quantum array.\n\n    Args:\n        qarr (Qarray): quantum array\n\n    Returns:\n        Normalized quantum array\n    \"\"\"\n    data = qarr.data\n\n    if qarr.qtype == Qtypes.oper:\n        evals, _ = jnp.linalg.eigh(data @ jnp.conj(data).T)\n        rho_norm = jnp.sum(jnp.sqrt(jnp.abs(evals)))\n        data = data / rho_norm\n    elif qarr.qtype in [Qtypes.ket, Qtypes.bra]:\n        data = data / jnp.linalg.norm(data)\n\n    return Qarray.create(data, dims=qarr.dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/settings.html","title":"settings","text":"<p>Core settings.</p>"},{"location":"reference/jaxquantum/core/solvers.html","title":"solvers","text":"<p>Solvers</p>"},{"location":"reference/jaxquantum/core/solvers.html#jaxquantum.core.solvers.calc_expect","title":"<code>calc_expect(op, states)</code>","text":"<p>Calculate expectation value of an operator given a list of states.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>Qarray</code> <p>operator</p> required <code>states</code> <code>List[Qarray]</code> <p>list of states</p> required <p>Returns:</p> Type Description <code>Array</code> <p>list of expectation values</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def calc_expect(op: Qarray, states: List[Qarray]) -&gt; Array:\n    \"\"\"Calculate expectation value of an operator given a list of states.\n\n    Args:\n        op: operator\n        states: list of states\n\n    Returns:\n        list of expectation values\n    \"\"\"\n\n    op = op.data\n    is_dm = states[0].is_dm()\n    states = jqts2jnps(states)\n\n    def calc_expect_ket_single(state: Array):\n        return (jnp.conj(state).T @ op @ state)[0][0]\n\n    def calc_expect_dm_single(state: Array):\n        return jnp.trace(op @ state)\n\n    if is_dm:\n        return vmap(calc_expect_dm_single)(states)\n    else:\n        return vmap(calc_expect_ket_single)(states)\n</code></pre>"},{"location":"reference/jaxquantum/core/solvers.html#jaxquantum.core.solvers.mesolve","title":"<code>mesolve(\u03c10, t_list, c_ops=None, H0=None, Ht=None, solver_options=None)</code>","text":"<p>Quantum Master Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>\u03c10</code> <code>Qarray</code> <p>initial state, must be a density matrix. For statevector evolution, please use sesolve.</p> required <code>t_list</code> <code>Array</code> <p>time list</p> required <code>c_ops</code> <code>Optional[List[Qarray]]</code> <p>list of collapse operators</p> <code>None</code> <code>H0</code> <code>Optional[Qarray]</code> <p>time independent Hamiltonian. If H0 is not None, it will override Ht.</p> <code>None</code> <code>Ht</code> <code>Optional[Callable[[float], Qarray]]</code> <p>time dependent Hamiltonian function.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def mesolve(\n    \u03c10: Qarray,\n    t_list: Array,\n    c_ops: Optional[List[Qarray]] = None,\n    H0: Optional[Qarray] = None,\n    Ht: Optional[Callable[[float], Qarray]] = None,\n    solver_options: Optional[SolverOptions] = None\n):\n    \"\"\"Quantum Master Equation solver.\n\n    Args:\n        \u03c10: initial state, must be a density matrix. For statevector evolution, please use sesolve.\n        t_list: time list\n        c_ops: list of collapse operators\n        H0: time independent Hamiltonian. If H0 is not None, it will override Ht.\n        Ht: time dependent Hamiltonian function.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    c_ops = c_ops or []\n\n    if len(c_ops) == 0 and \u03c10.qtype != Qtypes.oper:\n        logging.warning(\n            \"Consider using `jqt.sesolve()` instead, as `c_ops` is an empty list and the initial state is not a density matrix.\"\n        )\n\n    \u03c10 = \u03c10.to_dm()\n    dims = \u03c10.dims\n    \u03c10 = \u03c10.data\n\n    c_ops = [c_op.data for c_op in c_ops]\n    H0 = jnp.asarray(H0.data) if H0 is not None else None\n    Ht_data = lambda t: Ht(t).data if Ht is not None else None\n\n    ys = mesolve_data(\u03c10, t_list, c_ops, H0, Ht_data, solver_options)\n\n    return jnps2jqts(ys, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/solvers.html#jaxquantum.core.solvers.mesolve_data","title":"<code>mesolve_data(\u03c10, t_list, c_ops=None, H0=None, Ht=None, solver_options=None)</code>","text":"<p>Quantum Master Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>\u03c10</code> <code>Array</code> <p>initial state, must be a density matrix. For statevector evolution, please use sesolve.</p> required <code>t_list</code> <code>Array</code> <p>time list</p> required <code>c_ops</code> <code>Optional[List[Array]]</code> <p>list of collapse operators</p> <code>None</code> <code>H0</code> <code>Optional[Array]</code> <p>time independent Hamiltonian. If H0 is not None, it will override Ht.</p> <code>None</code> <code>Ht</code> <code>Optional[Callable[[float], Array]]</code> <p>time dependent Hamiltonian function.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def mesolve_data(\n    \u03c10: Array,\n    t_list: Array,\n    c_ops: Optional[List[Array]] = None,\n    H0: Optional[Array] = None,\n    Ht: Optional[Callable[[float], Array]] = None,\n    solver_options: Optional[SolverOptions] = None\n):\n    \"\"\"Quantum Master Equation solver.\n\n    Args:\n        \u03c10: initial state, must be a density matrix. For statevector evolution, please use sesolve.\n        t_list: time list\n        c_ops: list of collapse operators\n        H0: time independent Hamiltonian. If H0 is not None, it will override Ht.\n        Ht: time dependent Hamiltonian function.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    c_ops = c_ops or []\n\n    if len(c_ops) == 0:\n        logging.warning(\n            \"Consider using `jqt.sesolve()` instead, as `c_ops` is an empty list and the initial state is not a density matrix.\"\n        )\n\n    \u03c10 = \u03c10 + 0.0j\n\n    c_ops = jnp.asarray([c_op for c_op in c_ops]) + 0.0j\n    H0 = H0 + 0.0j if H0 is not None else None\n\n    def f(\n        t: float,\n        rho: Array,\n        args: Array,\n    ):\n        H0_val = args[0]\n        c_ops_val = args[1]\n\n        if H0_val is not None:\n            H = H0_val  # use H0 if given\n        else:\n            H = Ht(t)  # type: ignore\n            H = H + 0.0j\n\n        rho_dot = -1j * (H @ rho - rho @ H)\n\n        for op in c_ops_val:\n            rho_dot += spre(op)(rho)\n\n        return rho_dot\n\n\n    sol = solve(\u03c10, f, t_list, [H0, c_ops], solver_options=solver_options)\n\n    return sol.ys\n</code></pre>"},{"location":"reference/jaxquantum/core/solvers.html#jaxquantum.core.solvers.propagator","title":"<code>propagator(H, t, solver_options=None)</code>","text":"<p>Generate the propagator for a time dependent Hamiltonian. </p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Qarray or callable</code> <p>A Qarray static Hamiltonian OR a function that takes a time argument and returns a Hamiltonian. </p> required <code>ts</code> <code>float or Array</code> <p>A single time point or an Array of time points.</p> required <p>Returns:</p> Type Description <p>Qarray or List[Qarray]:  The propagator for the Hamiltonian at time t. OR a list of propagators for the Hamiltonian at each time in t.</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def propagator(\n    H: Union[Qarray, Callable[[float], Qarray]],\n    t: Union[float, Array],\n    solver_options=None\n):\n    \"\"\" Generate the propagator for a time dependent Hamiltonian. \n\n    Args:\n        H (Qarray or callable): \n            A Qarray static Hamiltonian OR\n            a function that takes a time argument and returns a Hamiltonian. \n        ts (float or Array): \n            A single time point or\n            an Array of time points.\n\n    Returns:\n        Qarray or List[Qarray]: \n            The propagator for the Hamiltonian at time t.\n            OR a list of propagators for the Hamiltonian at each time in t.\n\n    \"\"\"\n\n    t_is_scalar = robust_isscalar(t)\n\n    if isinstance(H, Qarray):\n        dims = H.dims \n        if t_is_scalar:\n            if t == 0:\n                return identity_like(H)\n\n            return jnp2jqt(propagator_0_data(H.data,t), dims=dims)\n        else:\n            f = lambda t: propagator_0_data(H.data,t)\n            return jnps2jqts(vmap(f)(t), dims)\n    else:\n        dims = H(0.0).dims\n        H_data = lambda t: H(t).data\n        if t_is_scalar:\n            if t == 0:\n                return identity_like(H(0.0))\n\n            ts = jnp.linspace(0,t,2)\n            return jnp2jqt(\n                propagator_t_data(H_data, ts, solver_options=solver_options)[1],\n                dims=dims\n            )\n        else:\n            ts = t \n            U_props = propagator_t_data(H_data, ts, solver_options=solver_options)\n            return jnps2jqts(U_props, dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/solvers.html#jaxquantum.core.solvers.propagator_0_data","title":"<code>propagator_0_data(H0, t)</code>","text":"<p>Generate the propagator for a time independent Hamiltonian. </p> <p>Parameters:</p> Name Type Description Default <code>H0</code> <code>Qarray</code> <p>The Hamiltonian.</p> required <p>Returns:</p> Name Type Description <code>Qarray</code> <p>The propagator for the time independent Hamiltonian.</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def propagator_0_data(\n    H0: Array,\n    t: float\n):\n    \"\"\" Generate the propagator for a time independent Hamiltonian. \n\n    Args:\n        H0 (Qarray): The Hamiltonian.\n\n    Returns:\n        Qarray: The propagator for the time independent Hamiltonian.\n    \"\"\"\n    return jsp.linalg.expm(-1j * H0 * t)\n</code></pre>"},{"location":"reference/jaxquantum/core/solvers.html#jaxquantum.core.solvers.propagator_t_data","title":"<code>propagator_t_data(Ht, ts, solver_options=None)</code>","text":"<p>Generate the propagator for a time dependent Hamiltonian. </p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>float</code> <p>The final time of the propagator.  Warning: Do not send in t. In this case, just do exp(-1j*Ht(0.0)).</p> required <code>Ht</code> <code>callable</code> <p>A function that takes a time argument and returns a Hamiltonian. </p> required <code>solver_options</code> <code>dict</code> <p>Options to pass to the solver.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Qarray</code> <p>The propagator for the time dependent Hamiltonian for the time range [0, t_final].</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def propagator_t_data(\n    Ht: Callable[[float], Array],\n    ts: Array, \n    solver_options=None\n):\n    \"\"\" Generate the propagator for a time dependent Hamiltonian. \n\n    Args:\n        ts (float): The final time of the propagator. \n            Warning: Do not send in t. In this case, just do exp(-1j*Ht(0.0)).\n        Ht (callable): A function that takes a time argument and returns a Hamiltonian. \n        solver_options (dict): Options to pass to the solver.\n\n    Returns:\n        Qarray: The propagator for the time dependent Hamiltonian for the time range [0, t_final].\n    \"\"\"\n    N = Ht(0).shape[0]\n    basis_states = jnp.eye(N)\n\n    def propogate_state(initial_state):\n        return sesolve_data(initial_state, ts, Ht=Ht, solver_options=solver_options)\n\n    U_prop = vmap(propogate_state)(basis_states)\n    U_prop = U_prop.transpose(1,0,2) # move time axis to the front\n    return U_prop\n</code></pre>"},{"location":"reference/jaxquantum/core/solvers.html#jaxquantum.core.solvers.sesolve","title":"<code>sesolve(\u03c8, t_list, H0=None, Ht=None, solver_options=None)</code>","text":"<p>Schr\u00f6dinger Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>\u03c8</code> <code>Qarray</code> <p>initial statevector</p> required <code>t_list</code> <code>Array</code> <p>time list</p> required <code>H0</code> <code>Optional[Qarray]</code> <p>time independent Hamiltonian. If H0 is not None, it will override Ht.</p> <code>None</code> <code>Ht</code> <code>Optional[Callable[[float], Qarray]]</code> <p>time dependent Hamiltonian function.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def sesolve(\n    \u03c8: Qarray,\n    t_list: Array,\n    H0: Optional[Qarray] = None,\n    Ht: Optional[Callable[[float], Qarray]] = None,\n    solver_options: Optional[SolverOptions] = None,\n):\n    \"\"\"Schr\u00f6dinger Equation solver.\n\n    Args:\n        \u03c8: initial statevector\n        t_list: time list\n        H0: time independent Hamiltonian. If H0 is not None, it will override Ht.\n        Ht: time dependent Hamiltonian function.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    if \u03c8.qtype == Qtypes.oper:\n        raise ValueError(\n            \"Please use `jqt.mesolve` for initial state inputs in density matrix form.\"\n        )\n\n    \u03c8 = \u03c8.to_ket()\n\n    dims = \u03c8.dims\n\n    \u03c8 = \u03c8.data \n    H0 = H0.data if H0 is not None else None\n    Ht_data = lambda t: Ht(t).data if Ht is not None else None\n\n    ys = sesolve_data(\u03c8, t_list, H0, Ht_data, solver_options)\n\n    return jnps2jqts(ys, dims=dims)\n</code></pre>"},{"location":"reference/jaxquantum/core/solvers.html#jaxquantum.core.solvers.sesolve_data","title":"<code>sesolve_data(\u03c8, t_list, H0=None, Ht=None, solver_options=None)</code>","text":"<p>Schr\u00f6dinger Equation solver.</p> <p>Parameters:</p> Name Type Description Default <code>\u03c8</code> <code>Array</code> <p>initial statevector</p> required <code>t_list</code> <code>Array</code> <p>time list</p> required <code>H0</code> <code>Optional[Array]</code> <p>time independent Hamiltonian. If H0 is not None, it will override Ht.</p> <code>None</code> <code>Ht</code> <code>Optional[Callable[[float], Array]]</code> <p>time dependent Hamiltonian function.</p> <code>None</code> <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>SolverOptions with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>list of states</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def sesolve_data(\n    \u03c8: Array,\n    t_list: Array,\n    H0: Optional[Array] = None,\n    Ht: Optional[Callable[[float], Array]] = None,\n    solver_options: Optional[SolverOptions] = None,\n):\n    \"\"\"Schr\u00f6dinger Equation solver.\n\n    Args:\n        \u03c8: initial statevector\n        t_list: time list\n        H0: time independent Hamiltonian. If H0 is not None, it will override Ht.\n        Ht: time dependent Hamiltonian function.\n        solver_options: SolverOptions with solver options\n\n    Returns:\n        list of states\n    \"\"\"\n\n    \u03c8 = \u03c8 + 0.0j\n    H0 = H0 + 0.0j if H0 is not None else None\n    solver_options = solver_options or {}\n\n    def f(\n        t: float,\n        \u03c8\u209c: Array,\n        args: Array,\n    ):\n        H0_val = args[0]\n\n        if H0_val is not None:\n            H = H0_val  # use H0 if given\n        else:\n            H = Ht(t)  # type: ignore\n        # print(\"H\", H.shape)\n        # print(\"psit\", \u03c8\u209c.shape)\n        \u03c8\u209c_dot = -1j * (H @ \u03c8\u209c)\n\n        return \u03c8\u209c_dot\n\n\n    sol = solve(\u03c8, f, t_list, [H0], solver_options=solver_options)\n    return sol.ys\n</code></pre>"},{"location":"reference/jaxquantum/core/solvers.html#jaxquantum.core.solvers.solve","title":"<code>solve(\u03c10, f, t_list, args, solver_options=None)</code>","text":"<p>Gets teh desired solver from diffrax.</p> <p>Parameters:</p> Name Type Description Default <code>solver_options</code> <code>Optional[SolverOptions]</code> <p>dictionary with solver options</p> <code>None</code> <p>Returns:</p> Type Description <p>solution</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def solve(\u03c10, f, t_list, args, solver_options: Optional[SolverOptions] = None):\n    \"\"\" Gets teh desired solver from diffrax.\n\n    Args:\n        solver_options: dictionary with solver options\n\n    Returns:\n        solution \n    \"\"\"\n\n    # f and ts\n    term = ODETerm(f)\n    saveat = SaveAt(ts=t_list)\n\n    # solver \n    solver_options = solver_options or SolverOptions.create()\n\n    solver_name = solver_options.solver\n    solver = getattr(diffrax, solver_name)()\n    stepsize_controller = PIDController(rtol=1e-6, atol=1e-6)\n\n    # solve!\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', UserWarning) # NOTE: suppresses complex dtype warning in diffrax\n        sol = diffeqsolve(\n            term,\n            solver,\n            t0=t_list[0],\n            t1=t_list[-1],\n            dt0=t_list[1] - t_list[0],\n            y0=\u03c10,\n            saveat=saveat,\n            stepsize_controller=stepsize_controller,\n            args=args,\n            max_steps=solver_options.max_steps,\n            progress_meter=CustomProgressMeter() if solver_options.progress_meter else NoProgressMeter(),\n        )   \n\n    return sol\n</code></pre>"},{"location":"reference/jaxquantum/core/solvers.html#jaxquantum.core.solvers.spre","title":"<code>spre(op)</code>","text":"<p>Superoperator generator.</p> <p>Parameters:</p> Name Type Description Default <code>op</code> <code>Array</code> <p>operator to be turned into a superoperator</p> required <p>Returns:</p> Type Description <code>Callable[[Array], Array]</code> <p>superoperator function</p> Source code in <code>jaxquantum/core/solvers.py</code> <pre><code>def spre(op: Array) -&gt; Callable[[Array], Array]:\n    \"\"\"Superoperator generator.\n\n    Args:\n        op: operator to be turned into a superoperator\n\n    Returns:\n        superoperator function\n    \"\"\"\n    op_dag = op.conj().T\n    return lambda rho: 0.5 * (\n        2 * op @ rho @ op_dag - rho @ op_dag @ op - op_dag @ op @ rho\n    )\n</code></pre>"},{"location":"reference/jaxquantum/core/visualization.html","title":"visualization","text":"<p>Visualization utils.</p>"},{"location":"reference/jaxquantum/core/visualization.html#jaxquantum.core.visualization.plot_qp","title":"<code>plot_qp(state, pts, ax=None, contour=True, qp_type=WIGNER)</code>","text":"<p>Plot quasi-probability distribution.</p> <p>TODO: decouple this from qutip.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>statevector</p> required <code>pts</code> <p>points to evaluate quasi-probability distribution on</p> required <code>dim</code> <p>dimensions of state</p> required <code>ax</code> <p>matplotlib axis to plot on</p> <code>None</code> <code>contour</code> <p>make the plot use contouring</p> <code>True</code> <code>qp_type</code> <p>type of quasi probability distribution (\"wigner\", \"qfunc\")</p> <code>WIGNER</code> <p>Returns:</p> Type Description <p>axis on which the plot was plotted.</p> Source code in <code>jaxquantum/core/visualization.py</code> <pre><code>def plot_qp(state, pts, ax=None, contour=True, qp_type=WIGNER):\n    \"\"\"Plot quasi-probability distribution.\n\n    TODO: decouple this from qutip.\n\n    Args:\n        state: statevector\n        pts: points to evaluate quasi-probability distribution on\n        dim: dimensions of state\n        ax: matplotlib axis to plot on\n        contour: make the plot use contouring\n        qp_type: type of quasi probability distribution (\"wigner\", \"qfunc\")\n\n    Returns:\n        axis on which the plot was plotted.\n    \"\"\"\n    pts = np.array(pts)\n    state = jqt2qt(state)\n    if ax is None:\n        _, ax = plt.subplots(1, figsize=(4, 3), dpi=200)\n    # fig = ax.get_figure()\n\n    if qp_type == WIGNER:\n        vmin = -1\n        vmax = 1\n        scale = np.pi / 2\n        cmap = \"seismic\"\n    elif qp_type == QFUNC:\n        vmin = 0\n        vmax = 1\n        scale = np.pi\n        cmap = \"jet\"\n\n    QP = scale * getattr(qt, qp_type)(state, pts, pts, g=2)\n\n    if contour:\n        im = ax.contourf(\n            pts,\n            pts,\n            QP,\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            levels=np.linspace(vmin, vmax, 101),\n        )\n    else:\n        im = ax.pcolormesh(\n            pts,\n            pts,\n            QP,\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n        )\n    ax.axhline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n    ax.axvline(0, linestyle=\"-\", color=\"black\", alpha=0.7)\n    ax.grid()\n    ax.set_aspect(\"equal\", adjustable=\"box\")\n    return im\n</code></pre>"},{"location":"reference/jaxquantum/utils/index.html","title":"utils","text":"<p>Utils</p>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.comb","title":"<code>comb(N, k)</code>","text":"<p>NCk</p>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.comb--todo-replace-with-jspspecialcomb-once-issue-is-closed","title":"TODO: replace with jsp.special.comb once issue is closed:","text":"<p>https://github.com/google/jax/issues/9709</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>total items</p> required <code>k</code> required <p>Returns:</p> Name Type Description <code>NCk</code> <p>N choose k</p> Source code in <code>jaxquantum/utils/utils.py</code> <pre><code>def comb(N, k):\n    \"\"\"\n    NCk\n\n    #TODO: replace with jsp.special.comb once issue is closed:\n    https://github.com/google/jax/issues/9709\n\n    Args:\n        N: total items\n        k: # of items to choose\n\n    Returns:\n        NCk: N choose k\n    \"\"\"\n    one = 1\n    N_plus_1 = lax.add(N, one)\n    k_plus_1 = lax.add(k, one)\n    return lax.exp(\n        lax.sub(\n            gammaln(N_plus_1), lax.add(gammaln(k_plus_1), gammaln(lax.sub(N_plus_1, k)))\n        )\n    )\n</code></pre>"},{"location":"reference/jaxquantum/utils/index.html#jaxquantum.utils.comb--of-items-to-choose","title":"of items to choose","text":""},{"location":"reference/jaxquantum/utils/utils.html","title":"utils","text":"<p>JAX Utils</p>"},{"location":"reference/jaxquantum/utils/utils.html#jaxquantum.utils.utils.comb","title":"<code>comb(N, k)</code>","text":"<p>NCk</p>"},{"location":"reference/jaxquantum/utils/utils.html#jaxquantum.utils.utils.comb--todo-replace-with-jspspecialcomb-once-issue-is-closed","title":"TODO: replace with jsp.special.comb once issue is closed:","text":"<p>https://github.com/google/jax/issues/9709</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <p>total items</p> required <code>k</code> required <p>Returns:</p> Name Type Description <code>NCk</code> <p>N choose k</p> Source code in <code>jaxquantum/utils/utils.py</code> <pre><code>def comb(N, k):\n    \"\"\"\n    NCk\n\n    #TODO: replace with jsp.special.comb once issue is closed:\n    https://github.com/google/jax/issues/9709\n\n    Args:\n        N: total items\n        k: # of items to choose\n\n    Returns:\n        NCk: N choose k\n    \"\"\"\n    one = 1\n    N_plus_1 = lax.add(N, one)\n    k_plus_1 = lax.add(k, one)\n    return lax.exp(\n        lax.sub(\n            gammaln(N_plus_1), lax.add(gammaln(k_plus_1), gammaln(lax.sub(N_plus_1, k)))\n        )\n    )\n</code></pre>"},{"location":"reference/jaxquantum/utils/utils.html#jaxquantum.utils.utils.comb--of-items-to-choose","title":"of items to choose","text":""}]}